/* tslint:disable */
/* eslint-disable */
/**
 * VVintage documentation
 * This is VVintage\'s APIs description
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AmenitiesPaginationResultDto
 */
export interface AmenitiesPaginationResultDto {
    /**
     * 
     * @type {Array<Amenity>}
     * @memberof AmenitiesPaginationResultDto
     */
    'data': Array<Amenity>;
    /**
     * 
     * @type {UsersPaginationResultDtoMeta}
     * @memberof AmenitiesPaginationResultDto
     */
    'meta': UsersPaginationResultDtoMeta;
}
/**
 * 
 * @export
 * @interface Amenity
 */
export interface Amenity {
    /**
     * 
     * @type {string}
     * @memberof Amenity
     */
    'id': string;
    /**
     * Soft delete flag
     * @type {boolean}
     * @memberof Amenity
     */
    'isDeleted': boolean;
    /**
     * Soft delete timestamp
     * @type {string}
     * @memberof Amenity
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof Amenity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Amenity
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Amenity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Amenity
     */
    'slug': string;
    /**
     * Icon image for the amenity
     * @type {Image}
     * @memberof Amenity
     */
    'icon': Image | null;
    /**
     * 
     * @type {string}
     * @memberof Amenity
     */
    'type': AmenityTypeEnum;
}

export const AmenityTypeEnum = {
    Room: 'ROOM',
    Property: 'PROPERTY',
    Service: 'SERVICE'
} as const;

export type AmenityTypeEnum = typeof AmenityTypeEnum[keyof typeof AmenityTypeEnum];

/**
 * 
 * @export
 * @interface Branch
 */
export interface Branch {
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'id': string;
    /**
     * Soft delete flag
     * @type {boolean}
     * @memberof Branch
     */
    'isDeleted': boolean;
    /**
     * Soft delete timestamp
     * @type {string}
     * @memberof Branch
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'updatedAt': string;
    /**
     * ID of the province where this branch is located
     * @type {string}
     * @memberof Branch
     */
    'provinceId': string;
    /**
     * Province where this branch is located
     * @type {Province}
     * @memberof Branch
     */
    'province'?: Province;
    /**
     * Branch\'s thumbnail image
     * @type {Image}
     * @memberof Branch
     */
    'thumbnail': Image;
    /**
     * Branch\'s image gallery
     * @type {Array<Image>}
     * @memberof Branch
     */
    'images': Array<Image>;
    /**
     * Branch\'s name
     * @type {string}
     * @memberof Branch
     */
    'name': string;
    /**
     * Branch\'s slug
     * @type {string}
     * @memberof Branch
     */
    'slug': string;
    /**
     * Branch\'s description
     * @type {string}
     * @memberof Branch
     */
    'description': string;
    /**
     * Branch\'s contact phone number
     * @type {string}
     * @memberof Branch
     */
    'phone': string;
    /**
     * Branch\'s active status
     * @type {boolean}
     * @memberof Branch
     */
    'is_active': boolean;
    /**
     * Branch\'s physical address
     * @type {string}
     * @memberof Branch
     */
    'address': string;
    /**
     * Branch\'s geographical location
     * @type {object}
     * @memberof Branch
     */
    'location': object;
    /**
     * Branch\'s rating
     * @type {number}
     * @memberof Branch
     */
    'rating': number;
}
/**
 * 
 * @export
 * @interface BranchDetail
 */
export interface BranchDetail {
    /**
     * 
     * @type {string}
     * @memberof BranchDetail
     */
    'id': string;
    /**
     * Soft delete flag
     * @type {boolean}
     * @memberof BranchDetail
     */
    'isDeleted': boolean;
    /**
     * Soft delete timestamp
     * @type {string}
     * @memberof BranchDetail
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof BranchDetail
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BranchDetail
     */
    'updatedAt': string;
    /**
     * ID of the province where this branch is located
     * @type {string}
     * @memberof BranchDetail
     */
    'provinceId': string;
    /**
     * Province where this branch is located
     * @type {Province}
     * @memberof BranchDetail
     */
    'province'?: Province;
    /**
     * Branch\'s thumbnail image
     * @type {Image}
     * @memberof BranchDetail
     */
    'thumbnail': Image;
    /**
     * Branch\'s image gallery
     * @type {Array<Image>}
     * @memberof BranchDetail
     */
    'images': Array<Image>;
    /**
     * Branch\'s name
     * @type {string}
     * @memberof BranchDetail
     */
    'name': string;
    /**
     * Branch\'s slug
     * @type {string}
     * @memberof BranchDetail
     */
    'slug': string;
    /**
     * Branch\'s description
     * @type {string}
     * @memberof BranchDetail
     */
    'description': string;
    /**
     * Branch\'s contact phone number
     * @type {string}
     * @memberof BranchDetail
     */
    'phone': string;
    /**
     * Branch\'s active status
     * @type {boolean}
     * @memberof BranchDetail
     */
    'is_active': boolean;
    /**
     * Branch\'s physical address
     * @type {string}
     * @memberof BranchDetail
     */
    'address': string;
    /**
     * Branch\'s geographical location
     * @type {object}
     * @memberof BranchDetail
     */
    'location': object;
    /**
     * Branch\'s rating
     * @type {number}
     * @memberof BranchDetail
     */
    'rating': number;
    /**
     * List of rooms available in the branch
     * @type {Array<HotelRoom>}
     * @memberof BranchDetail
     */
    'rooms': Array<HotelRoom>;
}
/**
 * 
 * @export
 * @interface BranchesInfinitePaginationResultDto
 */
export interface BranchesInfinitePaginationResultDto {
    /**
     * 
     * @type {Array<Branch>}
     * @memberof BranchesInfinitePaginationResultDto
     */
    'data': Array<Branch>;
    /**
     * 
     * @type {boolean}
     * @memberof BranchesInfinitePaginationResultDto
     */
    'hasNextPage': boolean;
}
/**
 * 
 * @export
 * @interface BranchesPaginationResultDto
 */
export interface BranchesPaginationResultDto {
    /**
     * 
     * @type {Array<Branch>}
     * @memberof BranchesPaginationResultDto
     */
    'data': Array<Branch>;
    /**
     * 
     * @type {UsersPaginationResultDtoMeta}
     * @memberof BranchesPaginationResultDto
     */
    'meta': UsersPaginationResultDtoMeta;
}
/**
 * 
 * @export
 * @interface CreateAmenityDto
 */
export interface CreateAmenityDto {
    /**
     * The name of the amenity
     * @type {string}
     * @memberof CreateAmenityDto
     */
    'name': string;
    /**
     * URL-friendly version of the name (lowercase, hyphenated)
     * @type {string}
     * @memberof CreateAmenityDto
     */
    'slug': string;
    /**
     * Type of amenity (ROOM, PROPERTY, or SERVICE)
     * @type {string}
     * @memberof CreateAmenityDto
     */
    'type': CreateAmenityDtoTypeEnum;
    /**
     * Icon image details
     * @type {Image}
     * @memberof CreateAmenityDto
     */
    'icon': Image;
}

export const CreateAmenityDtoTypeEnum = {
    Room: 'ROOM',
    Property: 'PROPERTY',
    Service: 'SERVICE'
} as const;

export type CreateAmenityDtoTypeEnum = typeof CreateAmenityDtoTypeEnum[keyof typeof CreateAmenityDtoTypeEnum];

/**
 * 
 * @export
 * @interface CreateBranchDto
 */
export interface CreateBranchDto {
    /**
     * ID of the province where this branch is located
     * @type {string}
     * @memberof CreateBranchDto
     */
    'provinceId': string;
    /**
     * The branch\'s thumbnail image.
     * @type {Image}
     * @memberof CreateBranchDto
     */
    'thumbnail': Image;
    /**
     * The branch\'s images.
     * @type {Array<Image>}
     * @memberof CreateBranchDto
     */
    'images': Array<Image>;
    /**
     * The branch\'s name.
     * @type {string}
     * @memberof CreateBranchDto
     */
    'name': string;
    /**
     * The branch\'s slug.
     * @type {string}
     * @memberof CreateBranchDto
     */
    'slug': string;
    /**
     * The branch\'s description.
     * @type {string}
     * @memberof CreateBranchDto
     */
    'description': string;
    /**
     * The branch\'s phone number.
     * @type {string}
     * @memberof CreateBranchDto
     */
    'phone': string;
    /**
     * The branch\'s active status.
     * @type {boolean}
     * @memberof CreateBranchDto
     */
    'is_active': boolean;
    /**
     * The branch\'s address.
     * @type {string}
     * @memberof CreateBranchDto
     */
    'address': string;
    /**
     * Branch\'s geographical location
     * @type {LocationDto}
     * @memberof CreateBranchDto
     */
    'location': LocationDto;
    /**
     * The branch\'s rating.
     * @type {number}
     * @memberof CreateBranchDto
     */
    'rating': number;
}
/**
 * 
 * @export
 * @interface CreateProvinceDto
 */
export interface CreateProvinceDto {
    /**
     * Name of the province
     * @type {string}
     * @memberof CreateProvinceDto
     */
    'name': string;
    /**
     * ZIP/Postal code of the province
     * @type {string}
     * @memberof CreateProvinceDto
     */
    'zip_code': string;
    /**
     * URL-friendly slug of the province name
     * @type {string}
     * @memberof CreateProvinceDto
     */
    'slug': string;
}
/**
 * 
 * @export
 * @interface CreateRoomDetailDto
 */
export interface CreateRoomDetailDto {
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDetailDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDetailDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDetailDto
     */
    'room_type': CreateRoomDetailDtoRoomTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDetailDto
     */
    'bed_type': CreateRoomDetailDtoBedTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateRoomDetailDto
     */
    'amenityIds': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CreateRoomDetailDto
     */
    'max_adults': number;
    /**
     * 
     * @type {number}
     * @memberof CreateRoomDetailDto
     */
    'max_children': number;
    /**
     * 
     * @type {number}
     * @memberof CreateRoomDetailDto
     */
    'quantity': number;
}

export const CreateRoomDetailDtoRoomTypeEnum = {
    Standard: 'STANDARD',
    Superior: 'SUPERIOR',
    Deluxe: 'DELUXE'
} as const;

export type CreateRoomDetailDtoRoomTypeEnum = typeof CreateRoomDetailDtoRoomTypeEnum[keyof typeof CreateRoomDetailDtoRoomTypeEnum];
export const CreateRoomDetailDtoBedTypeEnum = {
    Single: 'SINGLE',
    Double: 'DOUBLE',
    Queen: 'QUEEN',
    King: 'KING'
} as const;

export type CreateRoomDetailDtoBedTypeEnum = typeof CreateRoomDetailDtoBedTypeEnum[keyof typeof CreateRoomDetailDtoBedTypeEnum];

/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * The user\'s email address.
     * @type {string}
     * @memberof CreateUserDto
     */
    'email'?: string;
    /**
     * The user\'s phone number.
     * @type {string}
     * @memberof CreateUserDto
     */
    'phone'?: string;
    /**
     * The user\'s password.
     * @type {string}
     * @memberof CreateUserDto
     */
    'password': string;
    /**
     * The user\'s name.
     * @type {string}
     * @memberof CreateUserDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface FilterAmenityDto
 */
export interface FilterAmenityDto {
    /**
     * 
     * @type {string}
     * @memberof FilterAmenityDto
     */
    'types'?: FilterAmenityDtoTypesEnum;
    /**
     * 
     * @type {string}
     * @memberof FilterAmenityDto
     */
    'search'?: string;
}

export const FilterAmenityDtoTypesEnum = {
    Room: 'ROOM',
    Property: 'PROPERTY',
    Service: 'SERVICE'
} as const;

export type FilterAmenityDtoTypesEnum = typeof FilterAmenityDtoTypesEnum[keyof typeof FilterAmenityDtoTypesEnum];

/**
 * 
 * @export
 * @interface FilterBranchesDto
 */
export interface FilterBranchesDto {
    /**
     * Search by keyword
     * @type {string}
     * @memberof FilterBranchesDto
     */
    'keyword'?: string;
    /**
     * Filter by active status
     * @type {boolean}
     * @memberof FilterBranchesDto
     */
    'is_active'?: boolean;
    /**
     * Filter by rating
     * @type {number}
     * @memberof FilterBranchesDto
     */
    'rating'?: number;
    /**
     * Filter by province
     * @type {string}
     * @memberof FilterBranchesDto
     */
    'provinceId'?: string;
    /**
     * Filter by province slug
     * @type {string}
     * @memberof FilterBranchesDto
     */
    'provinceSlug'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FilterBranchesDto
     */
    'amenities'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FilterProvincesDto
 */
export interface FilterProvincesDto {
    /**
     * Search by keyword
     * @type {string}
     * @memberof FilterProvincesDto
     */
    'keyword'?: string;
}
/**
 * 
 * @export
 * @interface FilterUserDto
 */
export interface FilterUserDto {
    /**
     * 
     * @type {string}
     * @memberof FilterUserDto
     */
    'roles'?: FilterUserDtoRolesEnum;
}

export const FilterUserDtoRolesEnum = {
    User: 'USER',
    Staff: 'STAFF',
    Admin: 'ADMIN'
} as const;

export type FilterUserDtoRolesEnum = typeof FilterUserDtoRolesEnum[keyof typeof FilterUserDtoRolesEnum];

/**
 * 
 * @export
 * @interface HotelRoom
 */
export interface HotelRoom {
    /**
     * 
     * @type {string}
     * @memberof HotelRoom
     */
    'id': string;
    /**
     * Soft delete flag
     * @type {boolean}
     * @memberof HotelRoom
     */
    'isDeleted': boolean;
    /**
     * Soft delete timestamp
     * @type {string}
     * @memberof HotelRoom
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof HotelRoom
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof HotelRoom
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof HotelRoom
     */
    'name': string;
    /**
     * 
     * @type {Image}
     * @memberof HotelRoom
     */
    'thumbnail': Image;
    /**
     * 
     * @type {Array<Image>}
     * @memberof HotelRoom
     */
    'images': Array<Image>;
    /**
     * 
     * @type {string}
     * @memberof HotelRoom
     */
    'status': HotelRoomStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof HotelRoom
     */
    'branchId': string;
    /**
     * 
     * @type {string}
     * @memberof HotelRoom
     */
    'detailId': string;
    /**
     * 
     * @type {number}
     * @memberof HotelRoom
     */
    'base_price_per_hour': number;
    /**
     * 
     * @type {number}
     * @memberof HotelRoom
     */
    'special_price_per_hour'?: number;
    /**
     * 
     * @type {number}
     * @memberof HotelRoom
     */
    'base_price_per_night': number;
    /**
     * 
     * @type {number}
     * @memberof HotelRoom
     */
    'special_price_per_night'?: number;
    /**
     * 
     * @type {number}
     * @memberof HotelRoom
     */
    'base_price_per_day': number;
    /**
     * 
     * @type {number}
     * @memberof HotelRoom
     */
    'special_price_per_day'?: number;
}

export const HotelRoomStatusEnum = {
    Available: 'AVAILABLE',
    Booked: 'BOOKED',
    Occupied: 'OCCUPIED',
    Maintenance: 'MAINTENANCE'
} as const;

export type HotelRoomStatusEnum = typeof HotelRoomStatusEnum[keyof typeof HotelRoomStatusEnum];

/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * The image\'s URL.
     * @type {string}
     * @memberof Image
     */
    'url': string;
    /**
     * The image\'s public ID in Cloudinary.
     * @type {string}
     * @memberof Image
     */
    'publicId': string;
}
/**
 * 
 * @export
 * @interface ImageUploadResponseDto
 */
export interface ImageUploadResponseDto {
    /**
     * The image\'s URL.
     * @type {string}
     * @memberof ImageUploadResponseDto
     */
    'url': string;
    /**
     * The image\'s public ID in Cloudinary.
     * @type {string}
     * @memberof ImageUploadResponseDto
     */
    'publicId': string;
}
/**
 * 
 * @export
 * @interface InitiateForgotPasswordEmailDto
 */
export interface InitiateForgotPasswordEmailDto {
    /**
     * Email address of the user who forgot their password
     * @type {string}
     * @memberof InitiateForgotPasswordEmailDto
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface LocationDto
 */
export interface LocationDto {
    /**
     * Latitude coordinate
     * @type {number}
     * @memberof LocationDto
     */
    'latitude': number;
    /**
     * Longitude coordinate
     * @type {number}
     * @memberof LocationDto
     */
    'longitude': number;
}
/**
 * 
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     * The user\'s email address or phone number.
     * @type {string}
     * @memberof LoginDto
     */
    'emailOrPhone': string;
    /**
     * The user\'s password.
     * @type {string}
     * @memberof LoginDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponseDto
 */
export interface LoginResponseDto {
    /**
     * New access token
     * @type {string}
     * @memberof LoginResponseDto
     */
    'accessToken': string;
    /**
     * Timestamp when the access token expires
     * @type {number}
     * @memberof LoginResponseDto
     */
    'accessTokenExpires': number;
    /**
     * New refresh token
     * @type {string}
     * @memberof LoginResponseDto
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface LogoutResponseDto
 */
export interface LogoutResponseDto {
    /**
     * Success message
     * @type {string}
     * @memberof LogoutResponseDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface Province
 */
export interface Province {
    /**
     * 
     * @type {string}
     * @memberof Province
     */
    'id': string;
    /**
     * Soft delete flag
     * @type {boolean}
     * @memberof Province
     */
    'isDeleted': boolean;
    /**
     * Soft delete timestamp
     * @type {string}
     * @memberof Province
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof Province
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Province
     */
    'updatedAt': string;
    /**
     * Name of the province
     * @type {string}
     * @memberof Province
     */
    'name': string;
    /**
     * ZIP/Postal code of the province
     * @type {string}
     * @memberof Province
     */
    'zip_code': string;
    /**
     * Slug of the province
     * @type {string}
     * @memberof Province
     */
    'slug': string;
    /**
     * 
     * @type {ProvinceCount}
     * @memberof Province
     */
    '_count'?: ProvinceCount;
}
/**
 * Count of branches in the province
 * @export
 * @interface ProvinceCount
 */
export interface ProvinceCount {
    /**
     * 
     * @type {number}
     * @memberof ProvinceCount
     */
    'branches'?: number;
}
/**
 * 
 * @export
 * @interface ProvincePaginationResultDto
 */
export interface ProvincePaginationResultDto {
    /**
     * 
     * @type {Array<Province>}
     * @memberof ProvincePaginationResultDto
     */
    'data': Array<Province>;
    /**
     * 
     * @type {UsersPaginationResultDtoMeta}
     * @memberof ProvincePaginationResultDto
     */
    'meta': UsersPaginationResultDtoMeta;
}
/**
 * 
 * @export
 * @interface QueryAmenityDto
 */
export interface QueryAmenityDto {
    /**
     * 
     * @type {number}
     * @memberof QueryAmenityDto
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryAmenityDto
     */
    'pageSize'?: number;
    /**
     * JSON string of FilterAmenityDto
     * @type {string}
     * @memberof QueryAmenityDto
     */
    'filters'?: string;
    /**
     * JSON string of SortAmenityDto
     * @type {string}
     * @memberof QueryAmenityDto
     */
    'sort'?: string;
}
/**
 * 
 * @export
 * @interface QueryBranchesDto
 */
export interface QueryBranchesDto {
    /**
     * 
     * @type {number}
     * @memberof QueryBranchesDto
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryBranchesDto
     */
    'pageSize'?: number;
    /**
     * JSON string of FilterBranchesDto
     * @type {string}
     * @memberof QueryBranchesDto
     */
    'filters'?: string;
    /**
     * JSON string of SortBranchDto[]
     * @type {string}
     * @memberof QueryBranchesDto
     */
    'sort'?: string;
}
/**
 * 
 * @export
 * @interface QueryProvincesDto
 */
export interface QueryProvincesDto {
    /**
     * 
     * @type {number}
     * @memberof QueryProvincesDto
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryProvincesDto
     */
    'pageSize'?: number;
    /**
     * JSON string of FilterProvincesDto
     * @type {string}
     * @memberof QueryProvincesDto
     */
    'filters'?: string;
    /**
     * JSON string of SortProvinceDto[]
     * @type {string}
     * @memberof QueryProvincesDto
     */
    'sort'?: string;
}
/**
 * 
 * @export
 * @interface QueryUsersDto
 */
export interface QueryUsersDto {
    /**
     * 
     * @type {number}
     * @memberof QueryUsersDto
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryUsersDto
     */
    'pageSize'?: number;
    /**
     * JSON string of FilterUserDto
     * @type {string}
     * @memberof QueryUsersDto
     */
    'filters'?: string;
    /**
     * JSON string of SortUserDto[]
     * @type {string}
     * @memberof QueryUsersDto
     */
    'sort'?: string;
}
/**
 * 
 * @export
 * @interface RefreshTokenDto
 */
export interface RefreshTokenDto {
    /**
     * The refresh token to renew access
     * @type {string}
     * @memberof RefreshTokenDto
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface RefreshTokenResponseDto
 */
export interface RefreshTokenResponseDto {
    /**
     * New access token
     * @type {string}
     * @memberof RefreshTokenResponseDto
     */
    'accessToken': string;
    /**
     * Timestamp when the access token expires
     * @type {number}
     * @memberof RefreshTokenResponseDto
     */
    'accessTokenExpires': number;
    /**
     * New refresh token
     * @type {string}
     * @memberof RefreshTokenResponseDto
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface RegisterDto
 */
export interface RegisterDto {
    /**
     * 
     * @type {CreateUserDto}
     * @memberof RegisterDto
     */
    'data': CreateUserDto;
    /**
     * 
     * @type {string}
     * @memberof RegisterDto
     */
    'accountIdentifier': RegisterDtoAccountIdentifierEnum;
}

export const RegisterDtoAccountIdentifierEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE'
} as const;

export type RegisterDtoAccountIdentifierEnum = typeof RegisterDtoAccountIdentifierEnum[keyof typeof RegisterDtoAccountIdentifierEnum];

/**
 * 
 * @export
 * @interface RegisterResponseDto
 */
export interface RegisterResponseDto {
    /**
     * The user\'s email address
     * @type {string}
     * @memberof RegisterResponseDto
     */
    'email'?: string;
    /**
     * The user\'s phone number
     * @type {string}
     * @memberof RegisterResponseDto
     */
    'phone'?: string;
    /**
     * The user\'s ID
     * @type {string}
     * @memberof RegisterResponseDto
     */
    'id': string;
    /**
     * The type of identifier used for registration
     * @type {string}
     * @memberof RegisterResponseDto
     */
    'identifier_type': RegisterResponseDtoIdentifierTypeEnum;
}

export const RegisterResponseDtoIdentifierTypeEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE'
} as const;

export type RegisterResponseDtoIdentifierTypeEnum = typeof RegisterResponseDtoIdentifierTypeEnum[keyof typeof RegisterResponseDtoIdentifierTypeEnum];

/**
 * 
 * @export
 * @interface ResetPasswordWithOTPEmailDto
 */
export interface ResetPasswordWithOTPEmailDto {
    /**
     * Email address of the user
     * @type {string}
     * @memberof ResetPasswordWithOTPEmailDto
     */
    'email': string;
    /**
     * Six digit verification code sent to email
     * @type {string}
     * @memberof ResetPasswordWithOTPEmailDto
     */
    'code': string;
    /**
     * New password to set
     * @type {string}
     * @memberof ResetPasswordWithOTPEmailDto
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface RevokeSessionResponseDto
 */
export interface RevokeSessionResponseDto {
    /**
     * Success message
     * @type {string}
     * @memberof RevokeSessionResponseDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface RoomDetail
 */
export interface RoomDetail {
    /**
     * 
     * @type {string}
     * @memberof RoomDetail
     */
    'id': string;
    /**
     * Soft delete flag
     * @type {boolean}
     * @memberof RoomDetail
     */
    'isDeleted': boolean;
    /**
     * Soft delete timestamp
     * @type {string}
     * @memberof RoomDetail
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof RoomDetail
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RoomDetail
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof RoomDetail
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RoomDetail
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof RoomDetail
     */
    'room_type': RoomDetailRoomTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RoomDetail
     */
    'bed_type': RoomDetailBedTypeEnum;
    /**
     * 
     * @type {Array<Amenity>}
     * @memberof RoomDetail
     */
    'amenities': Array<Amenity>;
    /**
     * 
     * @type {number}
     * @memberof RoomDetail
     */
    'max_adults': number;
    /**
     * 
     * @type {number}
     * @memberof RoomDetail
     */
    'max_children': number;
    /**
     * 
     * @type {number}
     * @memberof RoomDetail
     */
    'quantity': number;
    /**
     * 
     * @type {Array<HotelRoom>}
     * @memberof RoomDetail
     */
    'rooms': Array<HotelRoom>;
}

export const RoomDetailRoomTypeEnum = {
    Standard: 'STANDARD',
    Superior: 'SUPERIOR',
    Deluxe: 'DELUXE'
} as const;

export type RoomDetailRoomTypeEnum = typeof RoomDetailRoomTypeEnum[keyof typeof RoomDetailRoomTypeEnum];
export const RoomDetailBedTypeEnum = {
    Single: 'SINGLE',
    Double: 'DOUBLE',
    Queen: 'QUEEN',
    King: 'KING'
} as const;

export type RoomDetailBedTypeEnum = typeof RoomDetailBedTypeEnum[keyof typeof RoomDetailBedTypeEnum];

/**
 * 
 * @export
 * @interface RoomDetailPaginationResultDto
 */
export interface RoomDetailPaginationResultDto {
    /**
     * 
     * @type {Array<RoomDetail>}
     * @memberof RoomDetailPaginationResultDto
     */
    'data': Array<RoomDetail>;
    /**
     * 
     * @type {UsersPaginationResultDtoMeta}
     * @memberof RoomDetailPaginationResultDto
     */
    'meta': UsersPaginationResultDtoMeta;
}
/**
 * 
 * @export
 * @interface SessionResponseDto
 */
export interface SessionResponseDto {
    /**
     * List of active user sessions
     * @type {Array<string>}
     * @memberof SessionResponseDto
     */
    'sessions': Array<string>;
}
/**
 * 
 * @export
 * @interface SortAmenityDto
 */
export interface SortAmenityDto {
    /**
     * Key of Entity to sort
     * @type {string}
     * @memberof SortAmenityDto
     */
    'orderBy': string;
    /**
     * Order of sorting
     * @type {string}
     * @memberof SortAmenityDto
     */
    'order': SortAmenityDtoOrderEnum;
}

export const SortAmenityDtoOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortAmenityDtoOrderEnum = typeof SortAmenityDtoOrderEnum[keyof typeof SortAmenityDtoOrderEnum];

/**
 * 
 * @export
 * @interface SortBranchDto
 */
export interface SortBranchDto {
    /**
     * Key of Entity to sort
     * @type {string}
     * @memberof SortBranchDto
     */
    'orderBy': string;
    /**
     * Order of sorting
     * @type {string}
     * @memberof SortBranchDto
     */
    'order': SortBranchDtoOrderEnum;
}

export const SortBranchDtoOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortBranchDtoOrderEnum = typeof SortBranchDtoOrderEnum[keyof typeof SortBranchDtoOrderEnum];

/**
 * 
 * @export
 * @interface SortProvinceDto
 */
export interface SortProvinceDto {
    /**
     * Key of Entity to sort
     * @type {string}
     * @memberof SortProvinceDto
     */
    'orderBy': string;
    /**
     * Order of sorting
     * @type {string}
     * @memberof SortProvinceDto
     */
    'order': SortProvinceDtoOrderEnum;
}

export const SortProvinceDtoOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortProvinceDtoOrderEnum = typeof SortProvinceDtoOrderEnum[keyof typeof SortProvinceDtoOrderEnum];

/**
 * 
 * @export
 * @interface SortUserDto
 */
export interface SortUserDto {
    /**
     * Key of User
     * @type {string}
     * @memberof SortUserDto
     */
    'orderBy': string;
    /**
     * Order of sorting
     * @type {string}
     * @memberof SortUserDto
     */
    'order': SortUserDtoOrderEnum;
}

export const SortUserDtoOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortUserDtoOrderEnum = typeof SortUserDtoOrderEnum[keyof typeof SortUserDtoOrderEnum];

/**
 * 
 * @export
 * @interface UpdateAmenityDto
 */
export interface UpdateAmenityDto {
    /**
     * The name of the amenity
     * @type {string}
     * @memberof UpdateAmenityDto
     */
    'name'?: string;
    /**
     * URL-friendly version of the name (lowercase, hyphenated)
     * @type {string}
     * @memberof UpdateAmenityDto
     */
    'slug'?: string;
    /**
     * Type of amenity (ROOM, PROPERTY, or SERVICE)
     * @type {string}
     * @memberof UpdateAmenityDto
     */
    'type'?: UpdateAmenityDtoTypeEnum;
    /**
     * Icon image details
     * @type {Image}
     * @memberof UpdateAmenityDto
     */
    'icon'?: Image;
}

export const UpdateAmenityDtoTypeEnum = {
    Room: 'ROOM',
    Property: 'PROPERTY',
    Service: 'SERVICE'
} as const;

export type UpdateAmenityDtoTypeEnum = typeof UpdateAmenityDtoTypeEnum[keyof typeof UpdateAmenityDtoTypeEnum];

/**
 * 
 * @export
 * @interface UpdateBranchDto
 */
export interface UpdateBranchDto {
    /**
     * ID of the province where this branch is located
     * @type {string}
     * @memberof UpdateBranchDto
     */
    'provinceId'?: string;
    /**
     * The branch\'s thumbnail image.
     * @type {Image}
     * @memberof UpdateBranchDto
     */
    'thumbnail'?: Image;
    /**
     * The branch\'s images.
     * @type {Array<Image>}
     * @memberof UpdateBranchDto
     */
    'images'?: Array<Image>;
    /**
     * The branch\'s name.
     * @type {string}
     * @memberof UpdateBranchDto
     */
    'name'?: string;
    /**
     * The branch\'s slug.
     * @type {string}
     * @memberof UpdateBranchDto
     */
    'slug'?: string;
    /**
     * The branch\'s description.
     * @type {string}
     * @memberof UpdateBranchDto
     */
    'description'?: string;
    /**
     * The branch\'s phone number.
     * @type {string}
     * @memberof UpdateBranchDto
     */
    'phone'?: string;
    /**
     * The branch\'s active status.
     * @type {boolean}
     * @memberof UpdateBranchDto
     */
    'is_active'?: boolean;
    /**
     * The branch\'s address.
     * @type {string}
     * @memberof UpdateBranchDto
     */
    'address'?: string;
    /**
     * Branch\'s geographical location
     * @type {LocationDto}
     * @memberof UpdateBranchDto
     */
    'location'?: LocationDto;
    /**
     * The branch\'s rating.
     * @type {number}
     * @memberof UpdateBranchDto
     */
    'rating'?: number;
    /**
     * Amenities available in the branch
     * @type {Array<Amenity>}
     * @memberof UpdateBranchDto
     */
    'amenities': Array<Amenity>;
}
/**
 * 
 * @export
 * @interface UpdateProvinceDto
 */
export interface UpdateProvinceDto {
    /**
     * Name of the province
     * @type {string}
     * @memberof UpdateProvinceDto
     */
    'name'?: string;
    /**
     * ZIP/Postal code of the province
     * @type {string}
     * @memberof UpdateProvinceDto
     */
    'zip_code'?: string;
    /**
     * URL-friendly slug of the province name
     * @type {string}
     * @memberof UpdateProvinceDto
     */
    'slug'?: string;
}
/**
 * 
 * @export
 * @interface UpdateRoomDetailDto
 */
export interface UpdateRoomDetailDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDetailDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDetailDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDetailDto
     */
    'room_type'?: UpdateRoomDetailDtoRoomTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDetailDto
     */
    'bed_type'?: UpdateRoomDetailDtoBedTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateRoomDetailDto
     */
    'amenityIds'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof UpdateRoomDetailDto
     */
    'max_adults'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateRoomDetailDto
     */
    'max_children'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateRoomDetailDto
     */
    'quantity'?: number;
}

export const UpdateRoomDetailDtoRoomTypeEnum = {
    Standard: 'STANDARD',
    Superior: 'SUPERIOR',
    Deluxe: 'DELUXE'
} as const;

export type UpdateRoomDetailDtoRoomTypeEnum = typeof UpdateRoomDetailDtoRoomTypeEnum[keyof typeof UpdateRoomDetailDtoRoomTypeEnum];
export const UpdateRoomDetailDtoBedTypeEnum = {
    Single: 'SINGLE',
    Double: 'DOUBLE',
    Queen: 'QUEEN',
    King: 'KING'
} as const;

export type UpdateRoomDetailDtoBedTypeEnum = typeof UpdateRoomDetailDtoBedTypeEnum[keyof typeof UpdateRoomDetailDtoBedTypeEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * Soft delete flag
     * @type {boolean}
     * @memberof User
     */
    'isDeleted': boolean;
    /**
     * Soft delete timestamp
     * @type {string}
     * @memberof User
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phone': string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'verified_email': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'verified_phone': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'identifier_type': UserIdentifierTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_blocked': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role': UserRoleEnum;
}

export const UserIdentifierTypeEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE'
} as const;

export type UserIdentifierTypeEnum = typeof UserIdentifierTypeEnum[keyof typeof UserIdentifierTypeEnum];
export const UserRoleEnum = {
    User: 'USER',
    Staff: 'STAFF',
    Admin: 'ADMIN'
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];

/**
 * 
 * @export
 * @interface UsersPaginationResultDto
 */
export interface UsersPaginationResultDto {
    /**
     * 
     * @type {Array<User>}
     * @memberof UsersPaginationResultDto
     */
    'data': Array<User>;
    /**
     * 
     * @type {UsersPaginationResultDtoMeta}
     * @memberof UsersPaginationResultDto
     */
    'meta': UsersPaginationResultDtoMeta;
}
/**
 * 
 * @export
 * @interface UsersPaginationResultDtoMeta
 */
export interface UsersPaginationResultDtoMeta {
    /**
     * 
     * @type {number}
     * @memberof UsersPaginationResultDtoMeta
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof UsersPaginationResultDtoMeta
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof UsersPaginationResultDtoMeta
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof UsersPaginationResultDtoMeta
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface VerificationEmailDto
 */
export interface VerificationEmailDto {
    /**
     * Email address to send verification code
     * @type {string}
     * @memberof VerificationEmailDto
     */
    'to': string;
    /**
     * Verification code to be sent
     * @type {string}
     * @memberof VerificationEmailDto
     */
    'code': string;
    /**
     * Language for email template
     * @type {string}
     * @memberof VerificationEmailDto
     */
    'lang'?: VerificationEmailDtoLangEnum;
    /**
     * Type of verification email
     * @type {string}
     * @memberof VerificationEmailDto
     */
    'type': VerificationEmailDtoTypeEnum;
}

export const VerificationEmailDtoLangEnum = {
    En: 'en',
    Vi: 'vi'
} as const;

export type VerificationEmailDtoLangEnum = typeof VerificationEmailDtoLangEnum[keyof typeof VerificationEmailDtoLangEnum];
export const VerificationEmailDtoTypeEnum = {
    VerifyAccount: 'VERIFY_ACCOUNT',
    ForgotPassword: 'FORGOT_PASSWORD'
} as const;

export type VerificationEmailDtoTypeEnum = typeof VerificationEmailDtoTypeEnum[keyof typeof VerificationEmailDtoTypeEnum];

/**
 * 
 * @export
 * @interface VerifyCodeDto
 */
export interface VerifyCodeDto {
    /**
     * User ID
     * @type {string}
     * @memberof VerifyCodeDto
     */
    'userId': string;
    /**
     * Account type
     * @type {string}
     * @memberof VerifyCodeDto
     */
    'type': string;
    /**
     * Verification code
     * @type {string}
     * @memberof VerifyCodeDto
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface VerifyCodeResponseDto
 */
export interface VerifyCodeResponseDto {
    /**
     * Verification status
     * @type {boolean}
     * @memberof VerifyCodeResponseDto
     */
    'success': boolean;
    /**
     * User ID
     * @type {string}
     * @memberof VerifyCodeResponseDto
     */
    'userId': string;
    /**
     * Type of verification
     * @type {string}
     * @memberof VerifyCodeResponseDto
     */
    'type': VerifyCodeResponseDtoTypeEnum;
}

export const VerifyCodeResponseDtoTypeEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE'
} as const;

export type VerifyCodeResponseDtoTypeEnum = typeof VerifyCodeResponseDtoTypeEnum[keyof typeof VerifyCodeResponseDtoTypeEnum];

/**
 * 
 * @export
 * @interface VerifyEmailDto
 */
export interface VerifyEmailDto {
    /**
     * User ID
     * @type {string}
     * @memberof VerifyEmailDto
     */
    'userId': string;
    /**
     * Verification code sent to email
     * @type {string}
     * @memberof VerifyEmailDto
     */
    'code': string;
}

/**
 * AmenitiesApi - axios parameter creator
 * @export
 */
export const AmenitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new amenity
         * @param {CreateAmenityDto} createAmenityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerCreate: async (createAmenityDto: CreateAmenityDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAmenityDto' is not null or undefined
            assertParamExists('amenitiesControllerCreate', 'createAmenityDto', createAmenityDto)
            const localVarPath = `/api/amenities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAmenityDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get amenities
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterAmenityDto
         * @param {string} [sort] JSON string of SortAmenityDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerFindMany: async (page?: number, pageSize?: number, filters?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/amenities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('amenitiesControllerFindOne', 'id', id)
            const localVarPath = `/api/amenities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('amenitiesControllerRemove', 'id', id)
            const localVarPath = `/api/amenities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update amenity
         * @param {string} id 
         * @param {UpdateAmenityDto} updateAmenityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerUpdate: async (id: string, updateAmenityDto: UpdateAmenityDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('amenitiesControllerUpdate', 'id', id)
            // verify required parameter 'updateAmenityDto' is not null or undefined
            assertParamExists('amenitiesControllerUpdate', 'updateAmenityDto', updateAmenityDto)
            const localVarPath = `/api/amenities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAmenityDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AmenitiesApi - functional programming interface
 * @export
 */
export const AmenitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AmenitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new amenity
         * @param {CreateAmenityDto} createAmenityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async amenitiesControllerCreate(createAmenityDto: CreateAmenityDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Amenity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.amenitiesControllerCreate(createAmenityDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AmenitiesApi.amenitiesControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get amenities
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterAmenityDto
         * @param {string} [sort] JSON string of SortAmenityDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async amenitiesControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AmenitiesPaginationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.amenitiesControllerFindMany(page, pageSize, filters, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AmenitiesApi.amenitiesControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async amenitiesControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.amenitiesControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AmenitiesApi.amenitiesControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async amenitiesControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.amenitiesControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AmenitiesApi.amenitiesControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update amenity
         * @param {string} id 
         * @param {UpdateAmenityDto} updateAmenityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async amenitiesControllerUpdate(id: string, updateAmenityDto: UpdateAmenityDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Amenity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.amenitiesControllerUpdate(id, updateAmenityDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AmenitiesApi.amenitiesControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AmenitiesApi - factory interface
 * @export
 */
export const AmenitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AmenitiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new amenity
         * @param {CreateAmenityDto} createAmenityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerCreate(createAmenityDto: CreateAmenityDto, options?: RawAxiosRequestConfig): AxiosPromise<Amenity> {
            return localVarFp.amenitiesControllerCreate(createAmenityDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get amenities
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterAmenityDto
         * @param {string} [sort] JSON string of SortAmenityDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<AmenitiesPaginationResultDto> {
            return localVarFp.amenitiesControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.amenitiesControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.amenitiesControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update amenity
         * @param {string} id 
         * @param {UpdateAmenityDto} updateAmenityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerUpdate(id: string, updateAmenityDto: UpdateAmenityDto, options?: RawAxiosRequestConfig): AxiosPromise<Amenity> {
            return localVarFp.amenitiesControllerUpdate(id, updateAmenityDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AmenitiesApi - object-oriented interface
 * @export
 * @class AmenitiesApi
 * @extends {BaseAPI}
 */
export class AmenitiesApi extends BaseAPI {
    /**
     * 
     * @summary Create new amenity
     * @param {CreateAmenityDto} createAmenityDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmenitiesApi
     */
    public amenitiesControllerCreate(createAmenityDto: CreateAmenityDto, options?: RawAxiosRequestConfig) {
        return AmenitiesApiFp(this.configuration).amenitiesControllerCreate(createAmenityDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get amenities
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [filters] JSON string of FilterAmenityDto
     * @param {string} [sort] JSON string of SortAmenityDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmenitiesApi
     */
    public amenitiesControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return AmenitiesApiFp(this.configuration).amenitiesControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmenitiesApi
     */
    public amenitiesControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return AmenitiesApiFp(this.configuration).amenitiesControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmenitiesApi
     */
    public amenitiesControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return AmenitiesApiFp(this.configuration).amenitiesControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update amenity
     * @param {string} id 
     * @param {UpdateAmenityDto} updateAmenityDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmenitiesApi
     */
    public amenitiesControllerUpdate(id: string, updateAmenityDto: UpdateAmenityDto, options?: RawAxiosRequestConfig) {
        return AmenitiesApiFp(this.configuration).amenitiesControllerUpdate(id, updateAmenityDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AppApi - axios parameter creator
 * @export
 */
export const AppApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppApi - functional programming interface
 * @export
 */
export const AppApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerGetHello(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetHello(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppApi.appControllerGetHello']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AppApi - factory interface
 * @export
 */
export const AppApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.appControllerGetHello(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppApi - object-oriented interface
 * @export
 * @class AppApi
 * @extends {BaseAPI}
 */
export class AppApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppApi
     */
    public appControllerGetHello(options?: RawAxiosRequestConfig) {
        return AppApiFp(this.configuration).appControllerGetHello(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all active sessions for the current user
         * @summary Get active sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetActiveSessions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get analytics data for user sessions. Requires ADMIN role.
         * @summary Get session analytics
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetSessionAnalytics: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('authControllerGetSessionAnalytics', 'userId', userId)
            const localVarPath = `/api/auth/sessions/analytics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get suspicious activities for a specific user. Requires ADMIN role.
         * @summary Get suspicious activities
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetSuspiciousActivities: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('authControllerGetSuspiciousActivities', 'userId', userId)
            const localVarPath = `/api/auth/users/{userId}/suspicious-activities`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate forgot password process
         * @param {InitiateForgotPasswordEmailDto} initiateForgotPasswordEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerInitiateForgotPassword: async (initiateForgotPasswordEmailDto: InitiateForgotPasswordEmailDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'initiateForgotPasswordEmailDto' is not null or undefined
            assertParamExists('authControllerInitiateForgotPassword', 'initiateForgotPasswordEmailDto', initiateForgotPasswordEmailDto)
            const localVarPath = `/api/auth/forgot-password/email/initiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(initiateForgotPasswordEmailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userAgent 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (userAgent: string, loginDto: LoginDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAgent' is not null or undefined
            assertParamExists('authControllerLogin', 'userAgent', userAgent)
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('authControllerLogin', 'loginDto', loginDto)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (userAgent != null) {
                localVarHeaderParameter['user-agent'] = String(userAgent);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke the current refresh token, effectively logging out the user
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exchange a valid refresh token for a new access token and refresh token pair
         * @summary Refresh access token
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshTokens: async (refreshTokenDto: RefreshTokenDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenDto' is not null or undefined
            assertParamExists('authControllerRefreshTokens', 'refreshTokenDto', refreshTokenDto)
            const localVarPath = `/api/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister: async (registerDto: RegisterDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerDto' is not null or undefined
            assertParamExists('authControllerRegister', 'registerDto', registerDto)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset password using OTP
         * @param {ResetPasswordWithOTPEmailDto} resetPasswordWithOTPEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPasswordWithOTP: async (resetPasswordWithOTPEmailDto: ResetPasswordWithOTPEmailDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordWithOTPEmailDto' is not null or undefined
            assertParamExists('authControllerResetPasswordWithOTP', 'resetPasswordWithOTPEmailDto', resetPasswordWithOTPEmailDto)
            const localVarPath = `/api/auth/forgot-password/email/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordWithOTPEmailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke a specific session by its ID
         * @summary Revoke specific session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRevokeSession: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('authControllerRevokeSession', 'sessionId', sessionId)
            const localVarPath = `/api/auth/sessions/{sessionId}/revoke`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify email with OTP code
         * @param {VerifyEmailDto} verifyEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyEmail: async (verifyEmailDto: VerifyEmailDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyEmailDto' is not null or undefined
            assertParamExists('authControllerVerifyEmail', 'verifyEmailDto', verifyEmailDto)
            const localVarPath = `/api/auth/verify-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyEmailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all active sessions for the current user
         * @summary Get active sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetActiveSessions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetActiveSessions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetActiveSessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get analytics data for user sessions. Requires ADMIN role.
         * @summary Get session analytics
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetSessionAnalytics(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetSessionAnalytics(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetSessionAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get suspicious activities for a specific user. Requires ADMIN role.
         * @summary Get suspicious activities
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetSuspiciousActivities(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetSuspiciousActivities(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetSuspiciousActivities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Initiate forgot password process
         * @param {InitiateForgotPasswordEmailDto} initiateForgotPasswordEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerInitiateForgotPassword(initiateForgotPasswordEmailDto: InitiateForgotPasswordEmailDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerInitiateForgotPassword(initiateForgotPasswordEmailDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerInitiateForgotPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userAgent 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(userAgent: string, loginDto: LoginDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(userAgent, loginDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke the current refresh token, effectively logging out the user
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogoutResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exchange a valid refresh token for a new access token and refresh token pair
         * @summary Refresh access token
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefreshTokens(refreshTokenDto: RefreshTokenDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefreshTokens(refreshTokenDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerRefreshTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRegister(registerDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset password using OTP
         * @param {ResetPasswordWithOTPEmailDto} resetPasswordWithOTPEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerResetPasswordWithOTP(resetPasswordWithOTPEmailDto: ResetPasswordWithOTPEmailDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerResetPasswordWithOTP(resetPasswordWithOTPEmailDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerResetPasswordWithOTP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke a specific session by its ID
         * @summary Revoke specific session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRevokeSession(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RevokeSessionResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRevokeSession(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerRevokeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify email with OTP code
         * @param {VerifyEmailDto} verifyEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerVerifyEmail(verifyEmailDto: VerifyEmailDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerVerifyEmail(verifyEmailDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerVerifyEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Retrieve all active sessions for the current user
         * @summary Get active sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetActiveSessions(options?: RawAxiosRequestConfig): AxiosPromise<SessionResponseDto> {
            return localVarFp.authControllerGetActiveSessions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.authControllerGetProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * Get analytics data for user sessions. Requires ADMIN role.
         * @summary Get session analytics
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetSessionAnalytics(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerGetSessionAnalytics(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get suspicious activities for a specific user. Requires ADMIN role.
         * @summary Get suspicious activities
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetSuspiciousActivities(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerGetSuspiciousActivities(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initiate forgot password process
         * @param {InitiateForgotPasswordEmailDto} initiateForgotPasswordEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerInitiateForgotPassword(initiateForgotPasswordEmailDto: InitiateForgotPasswordEmailDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerInitiateForgotPassword(initiateForgotPasswordEmailDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userAgent 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(userAgent: string, loginDto: LoginDto, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponseDto> {
            return localVarFp.authControllerLogin(userAgent, loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke the current refresh token, effectively logging out the user
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout(options?: RawAxiosRequestConfig): AxiosPromise<LogoutResponseDto> {
            return localVarFp.authControllerLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * Exchange a valid refresh token for a new access token and refresh token pair
         * @summary Refresh access token
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshTokens(refreshTokenDto: RefreshTokenDto, options?: RawAxiosRequestConfig): AxiosPromise<RefreshTokenResponseDto> {
            return localVarFp.authControllerRefreshTokens(refreshTokenDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig): AxiosPromise<RegisterResponseDto> {
            return localVarFp.authControllerRegister(registerDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset password using OTP
         * @param {ResetPasswordWithOTPEmailDto} resetPasswordWithOTPEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPasswordWithOTP(resetPasswordWithOTPEmailDto: ResetPasswordWithOTPEmailDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerResetPasswordWithOTP(resetPasswordWithOTPEmailDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke a specific session by its ID
         * @summary Revoke specific session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRevokeSession(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<RevokeSessionResponseDto> {
            return localVarFp.authControllerRevokeSession(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify email with OTP code
         * @param {VerifyEmailDto} verifyEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyEmail(verifyEmailDto: VerifyEmailDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerVerifyEmail(verifyEmailDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Retrieve all active sessions for the current user
     * @summary Get active sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetActiveSessions(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetActiveSessions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetProfile(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get analytics data for user sessions. Requires ADMIN role.
     * @summary Get session analytics
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetSessionAnalytics(userId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetSessionAnalytics(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get suspicious activities for a specific user. Requires ADMIN role.
     * @summary Get suspicious activities
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetSuspiciousActivities(userId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetSuspiciousActivities(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initiate forgot password process
     * @param {InitiateForgotPasswordEmailDto} initiateForgotPasswordEmailDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerInitiateForgotPassword(initiateForgotPasswordEmailDto: InitiateForgotPasswordEmailDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerInitiateForgotPassword(initiateForgotPasswordEmailDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userAgent 
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogin(userAgent: string, loginDto: LoginDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogin(userAgent, loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke the current refresh token, effectively logging out the user
     * @summary Logout user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogout(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exchange a valid refresh token for a new access token and refresh token pair
     * @summary Refresh access token
     * @param {RefreshTokenDto} refreshTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRefreshTokens(refreshTokenDto: RefreshTokenDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRefreshTokens(refreshTokenDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterDto} registerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRegister(registerDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset password using OTP
     * @param {ResetPasswordWithOTPEmailDto} resetPasswordWithOTPEmailDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerResetPasswordWithOTP(resetPasswordWithOTPEmailDto: ResetPasswordWithOTPEmailDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerResetPasswordWithOTP(resetPasswordWithOTPEmailDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke a specific session by its ID
     * @summary Revoke specific session
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRevokeSession(sessionId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRevokeSession(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify email with OTP code
     * @param {VerifyEmailDto} verifyEmailDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerVerifyEmail(verifyEmailDto: VerifyEmailDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerVerifyEmail(verifyEmailDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BranchesApi - axios parameter creator
 * @export
 */
export const BranchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new branch
         * @param {CreateBranchDto} createBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerCreate: async (createBranchDto: CreateBranchDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBranchDto' is not null or undefined
            assertParamExists('branchControllerCreate', 'createBranchDto', createBranchDto)
            const localVarPath = `/api/branches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBranchDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all soft-deleted branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindDeleted: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/branches/deleted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all branches with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterBranchesDto
         * @param {string} [sort] JSON string of SortBranchDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindMany: async (page?: number, pageSize?: number, filters?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/branches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get branches with infinite scroll for client app
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterBranchesDto
         * @param {string} [sort] JSON string of SortBranchDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindManyInfinite: async (page?: number, pageSize?: number, filters?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/branches/infinite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get branch by ID or slug
         * @param {string} idOrSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindOne: async (idOrSlug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idOrSlug' is not null or undefined
            assertParamExists('branchControllerFindOne', 'idOrSlug', idOrSlug)
            const localVarPath = `/api/branches/{idOrSlug}`
                .replace(`{${"idOrSlug"}}`, encodeURIComponent(String(idOrSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get latest branches
         * @param {number} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerGetLatestBranches: async (body: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('branchControllerGetLatestBranches', 'body', body)
            const localVarPath = `/api/branches/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a branch
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('branchControllerRemove', 'id', id)
            const localVarPath = `/api/branches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a soft-deleted branch
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerRestore: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('branchControllerRestore', 'id', id)
            const localVarPath = `/api/branches/{id}/restore`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a branch
         * @param {string} id 
         * @param {UpdateBranchDto} updateBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerUpdate: async (id: string, updateBranchDto: UpdateBranchDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('branchControllerUpdate', 'id', id)
            // verify required parameter 'updateBranchDto' is not null or undefined
            assertParamExists('branchControllerUpdate', 'updateBranchDto', updateBranchDto)
            const localVarPath = `/api/branches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBranchDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BranchesApi - functional programming interface
 * @export
 */
export const BranchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BranchesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new branch
         * @param {CreateBranchDto} createBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerCreate(createBranchDto: CreateBranchDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerCreate(createBranchDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all soft-deleted branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerFindDeleted(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Branch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerFindDeleted(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerFindDeleted']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all branches with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterBranchesDto
         * @param {string} [sort] JSON string of SortBranchDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchesPaginationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerFindMany(page, pageSize, filters, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get branches with infinite scroll for client app
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterBranchesDto
         * @param {string} [sort] JSON string of SortBranchDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerFindManyInfinite(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchesInfinitePaginationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerFindManyInfinite(page, pageSize, filters, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerFindManyInfinite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get branch by ID or slug
         * @param {string} idOrSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerFindOne(idOrSlug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerFindOne(idOrSlug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get latest branches
         * @param {number} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerGetLatestBranches(body: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Branch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerGetLatestBranches(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerGetLatestBranches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a branch
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Restore a soft-deleted branch
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerRestore(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerRestore(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a branch
         * @param {string} id 
         * @param {UpdateBranchDto} updateBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerUpdate(id: string, updateBranchDto: UpdateBranchDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerUpdate(id, updateBranchDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BranchesApi - factory interface
 * @export
 */
export const BranchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BranchesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new branch
         * @param {CreateBranchDto} createBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerCreate(createBranchDto: CreateBranchDto, options?: RawAxiosRequestConfig): AxiosPromise<Branch> {
            return localVarFp.branchControllerCreate(createBranchDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all soft-deleted branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindDeleted(options?: RawAxiosRequestConfig): AxiosPromise<Array<Branch>> {
            return localVarFp.branchControllerFindDeleted(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all branches with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterBranchesDto
         * @param {string} [sort] JSON string of SortBranchDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<BranchesPaginationResultDto> {
            return localVarFp.branchControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get branches with infinite scroll for client app
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterBranchesDto
         * @param {string} [sort] JSON string of SortBranchDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindManyInfinite(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<BranchesInfinitePaginationResultDto> {
            return localVarFp.branchControllerFindManyInfinite(page, pageSize, filters, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get branch by ID or slug
         * @param {string} idOrSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindOne(idOrSlug: string, options?: RawAxiosRequestConfig): AxiosPromise<BranchDetail> {
            return localVarFp.branchControllerFindOne(idOrSlug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get latest branches
         * @param {number} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerGetLatestBranches(body: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Branch>> {
            return localVarFp.branchControllerGetLatestBranches(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a branch
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.branchControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a soft-deleted branch
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerRestore(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.branchControllerRestore(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a branch
         * @param {string} id 
         * @param {UpdateBranchDto} updateBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerUpdate(id: string, updateBranchDto: UpdateBranchDto, options?: RawAxiosRequestConfig): AxiosPromise<Branch> {
            return localVarFp.branchControllerUpdate(id, updateBranchDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BranchesApi - object-oriented interface
 * @export
 * @class BranchesApi
 * @extends {BaseAPI}
 */
export class BranchesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new branch
     * @param {CreateBranchDto} createBranchDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerCreate(createBranchDto: CreateBranchDto, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerCreate(createBranchDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all soft-deleted branches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerFindDeleted(options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerFindDeleted(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all branches with pagination and filters
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [filters] JSON string of FilterBranchesDto
     * @param {string} [sort] JSON string of SortBranchDto[]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get branches with infinite scroll for client app
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [filters] JSON string of FilterBranchesDto
     * @param {string} [sort] JSON string of SortBranchDto[]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerFindManyInfinite(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerFindManyInfinite(page, pageSize, filters, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get branch by ID or slug
     * @param {string} idOrSlug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerFindOne(idOrSlug: string, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerFindOne(idOrSlug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get latest branches
     * @param {number} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerGetLatestBranches(body: number, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerGetLatestBranches(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a branch
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a soft-deleted branch
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerRestore(id: string, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerRestore(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a branch
     * @param {string} id 
     * @param {UpdateBranchDto} updateBranchDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerUpdate(id: string, updateBranchDto: UpdateBranchDto, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerUpdate(id, updateBranchDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EmailApi - axios parameter creator
 * @export
 */
export const EmailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send verification email
         * @param {VerificationEmailDto} verificationEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailControllerSendVerificationEmail: async (verificationEmailDto: VerificationEmailDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verificationEmailDto' is not null or undefined
            assertParamExists('emailControllerSendVerificationEmail', 'verificationEmailDto', verificationEmailDto)
            const localVarPath = `/api/email/send-verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verificationEmailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailApi - functional programming interface
 * @export
 */
export const EmailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmailApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Send verification email
         * @param {VerificationEmailDto} verificationEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailControllerSendVerificationEmail(verificationEmailDto: VerificationEmailDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailControllerSendVerificationEmail(verificationEmailDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmailApi.emailControllerSendVerificationEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EmailApi - factory interface
 * @export
 */
export const EmailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmailApiFp(configuration)
    return {
        /**
         * 
         * @summary Send verification email
         * @param {VerificationEmailDto} verificationEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailControllerSendVerificationEmail(verificationEmailDto: VerificationEmailDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.emailControllerSendVerificationEmail(verificationEmailDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmailApi - object-oriented interface
 * @export
 * @class EmailApi
 * @extends {BaseAPI}
 */
export class EmailApi extends BaseAPI {
    /**
     * 
     * @summary Send verification email
     * @param {VerificationEmailDto} verificationEmailDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApi
     */
    public emailControllerSendVerificationEmail(verificationEmailDto: VerificationEmailDto, options?: RawAxiosRequestConfig) {
        return EmailApiFp(this.configuration).emailControllerSendVerificationEmail(verificationEmailDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get image by public id
         * @param {string} publicId Public ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetImageByPublicId: async (publicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicId' is not null or undefined
            assertParamExists('imagesControllerGetImageByPublicId', 'publicId', publicId)
            const localVarPath = `/api/images/{publicId}`
                .replace(`{${"publicId"}}`, encodeURIComponent(String(publicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload amenity icon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerUploadIcon: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/images/icon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload multiple image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerUploadImages: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get image by public id
         * @param {string} publicId Public ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerGetImageByPublicId(publicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerGetImageByPublicId(publicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerGetImageByPublicId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload amenity icon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerUploadIcon(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerUploadIcon(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerUploadIcon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload multiple image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerUploadImages(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageUploadResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerUploadImages(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerUploadImages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get image by public id
         * @param {string} publicId Public ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetImageByPublicId(publicId: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadResponseDto> {
            return localVarFp.imagesControllerGetImageByPublicId(publicId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload amenity icon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerUploadIcon(options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadResponseDto> {
            return localVarFp.imagesControllerUploadIcon(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload multiple image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerUploadImages(options?: RawAxiosRequestConfig): AxiosPromise<Array<ImageUploadResponseDto>> {
            return localVarFp.imagesControllerUploadImages(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
    /**
     * 
     * @summary Get image by public id
     * @param {string} publicId Public ID of the image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerGetImageByPublicId(publicId: string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerGetImageByPublicId(publicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload amenity icon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerUploadIcon(options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerUploadIcon(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload multiple image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerUploadImages(options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerUploadImages(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProvincesApi - axios parameter creator
 * @export
 */
export const ProvincesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new province
         * @param {CreateProvinceDto} createProvinceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerCreate: async (createProvinceDto: CreateProvinceDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProvinceDto' is not null or undefined
            assertParamExists('provincesControllerCreate', 'createProvinceDto', createProvinceDto)
            const localVarPath = `/api/provinces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProvinceDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all soft-deleted provinces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerFindDeleted: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/provinces/deleted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all provinces with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterProvincesDto
         * @param {string} [sort] JSON string of SortProvinceDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerFindMany: async (page?: number, pageSize?: number, filters?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/provinces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get province by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('provincesControllerFindOne', 'id', id)
            const localVarPath = `/api/provinces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a province
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('provincesControllerRemove', 'id', id)
            const localVarPath = `/api/provinces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a soft-deleted province
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerRestore: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('provincesControllerRestore', 'id', id)
            const localVarPath = `/api/provinces/{id}/restore`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a province
         * @param {string} id 
         * @param {UpdateProvinceDto} updateProvinceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerUpdate: async (id: string, updateProvinceDto: UpdateProvinceDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('provincesControllerUpdate', 'id', id)
            // verify required parameter 'updateProvinceDto' is not null or undefined
            assertParamExists('provincesControllerUpdate', 'updateProvinceDto', updateProvinceDto)
            const localVarPath = `/api/provinces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProvinceDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvincesApi - functional programming interface
 * @export
 */
export const ProvincesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProvincesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new province
         * @param {CreateProvinceDto} createProvinceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provincesControllerCreate(createProvinceDto: CreateProvinceDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Province>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provincesControllerCreate(createProvinceDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvincesApi.provincesControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all soft-deleted provinces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provincesControllerFindDeleted(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Province>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provincesControllerFindDeleted(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvincesApi.provincesControllerFindDeleted']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all provinces with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterProvincesDto
         * @param {string} [sort] JSON string of SortProvinceDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provincesControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvincePaginationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provincesControllerFindMany(page, pageSize, filters, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvincesApi.provincesControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get province by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provincesControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Province>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provincesControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvincesApi.provincesControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a province
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provincesControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provincesControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvincesApi.provincesControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Restore a soft-deleted province
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provincesControllerRestore(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provincesControllerRestore(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvincesApi.provincesControllerRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a province
         * @param {string} id 
         * @param {UpdateProvinceDto} updateProvinceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provincesControllerUpdate(id: string, updateProvinceDto: UpdateProvinceDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Province>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provincesControllerUpdate(id, updateProvinceDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvincesApi.provincesControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProvincesApi - factory interface
 * @export
 */
export const ProvincesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProvincesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new province
         * @param {CreateProvinceDto} createProvinceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerCreate(createProvinceDto: CreateProvinceDto, options?: RawAxiosRequestConfig): AxiosPromise<Province> {
            return localVarFp.provincesControllerCreate(createProvinceDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all soft-deleted provinces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerFindDeleted(options?: RawAxiosRequestConfig): AxiosPromise<Array<Province>> {
            return localVarFp.provincesControllerFindDeleted(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all provinces with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterProvincesDto
         * @param {string} [sort] JSON string of SortProvinceDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProvincePaginationResultDto> {
            return localVarFp.provincesControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get province by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Province> {
            return localVarFp.provincesControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a province
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.provincesControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a soft-deleted province
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerRestore(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.provincesControllerRestore(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a province
         * @param {string} id 
         * @param {UpdateProvinceDto} updateProvinceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerUpdate(id: string, updateProvinceDto: UpdateProvinceDto, options?: RawAxiosRequestConfig): AxiosPromise<Province> {
            return localVarFp.provincesControllerUpdate(id, updateProvinceDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvincesApi - object-oriented interface
 * @export
 * @class ProvincesApi
 * @extends {BaseAPI}
 */
export class ProvincesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new province
     * @param {CreateProvinceDto} createProvinceDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvincesApi
     */
    public provincesControllerCreate(createProvinceDto: CreateProvinceDto, options?: RawAxiosRequestConfig) {
        return ProvincesApiFp(this.configuration).provincesControllerCreate(createProvinceDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all soft-deleted provinces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvincesApi
     */
    public provincesControllerFindDeleted(options?: RawAxiosRequestConfig) {
        return ProvincesApiFp(this.configuration).provincesControllerFindDeleted(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all provinces with pagination and filters
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [filters] JSON string of FilterProvincesDto
     * @param {string} [sort] JSON string of SortProvinceDto[]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvincesApi
     */
    public provincesControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return ProvincesApiFp(this.configuration).provincesControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get province by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvincesApi
     */
    public provincesControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return ProvincesApiFp(this.configuration).provincesControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a province
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvincesApi
     */
    public provincesControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return ProvincesApiFp(this.configuration).provincesControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a soft-deleted province
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvincesApi
     */
    public provincesControllerRestore(id: string, options?: RawAxiosRequestConfig) {
        return ProvincesApiFp(this.configuration).provincesControllerRestore(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a province
     * @param {string} id 
     * @param {UpdateProvinceDto} updateProvinceDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvincesApi
     */
    public provincesControllerUpdate(id: string, updateProvinceDto: UpdateProvinceDto, options?: RawAxiosRequestConfig) {
        return ProvincesApiFp(this.configuration).provincesControllerUpdate(id, updateProvinceDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoomDetailsApi - axios parameter creator
 * @export
 */
export const RoomDetailsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new room detail
         * @param {CreateRoomDetailDto} createRoomDetailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerCreate: async (createRoomDetailDto: CreateRoomDetailDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRoomDetailDto' is not null or undefined
            assertParamExists('roomDetailControllerCreate', 'createRoomDetailDto', createRoomDetailDto)
            const localVarPath = `/api/room-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoomDetailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all room details with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {object} [filters] 
         * @param {Array<string>} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerFindMany: async (page?: number, pageSize?: number, filters?: object, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/room-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                for (const [key, value] of Object.entries(filters)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a room detail by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('roomDetailControllerFindOne', 'id', id)
            const localVarPath = `/api/room-details/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a room detail
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('roomDetailControllerRemove', 'id', id)
            const localVarPath = `/api/room-details/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a room detail
         * @param {string} id 
         * @param {UpdateRoomDetailDto} updateRoomDetailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerUpdate: async (id: string, updateRoomDetailDto: UpdateRoomDetailDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('roomDetailControllerUpdate', 'id', id)
            // verify required parameter 'updateRoomDetailDto' is not null or undefined
            assertParamExists('roomDetailControllerUpdate', 'updateRoomDetailDto', updateRoomDetailDto)
            const localVarPath = `/api/room-details/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoomDetailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomDetailsApi - functional programming interface
 * @export
 */
export const RoomDetailsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomDetailsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new room detail
         * @param {CreateRoomDetailDto} createRoomDetailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomDetailControllerCreate(createRoomDetailDto: CreateRoomDetailDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomDetailControllerCreate(createRoomDetailDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomDetailsApi.roomDetailControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all room details with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {object} [filters] 
         * @param {Array<string>} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomDetailControllerFindMany(page?: number, pageSize?: number, filters?: object, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDetailPaginationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomDetailControllerFindMany(page, pageSize, filters, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomDetailsApi.roomDetailControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a room detail by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomDetailControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomDetailControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomDetailsApi.roomDetailControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a room detail
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomDetailControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomDetailControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomDetailsApi.roomDetailControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a room detail
         * @param {string} id 
         * @param {UpdateRoomDetailDto} updateRoomDetailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomDetailControllerUpdate(id: string, updateRoomDetailDto: UpdateRoomDetailDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomDetailControllerUpdate(id, updateRoomDetailDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomDetailsApi.roomDetailControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoomDetailsApi - factory interface
 * @export
 */
export const RoomDetailsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomDetailsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new room detail
         * @param {CreateRoomDetailDto} createRoomDetailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerCreate(createRoomDetailDto: CreateRoomDetailDto, options?: RawAxiosRequestConfig): AxiosPromise<RoomDetail> {
            return localVarFp.roomDetailControllerCreate(createRoomDetailDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all room details with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {object} [filters] 
         * @param {Array<string>} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerFindMany(page?: number, pageSize?: number, filters?: object, sort?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<RoomDetailPaginationResultDto> {
            return localVarFp.roomDetailControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a room detail by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomDetail> {
            return localVarFp.roomDetailControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a room detail
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomDetailControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a room detail
         * @param {string} id 
         * @param {UpdateRoomDetailDto} updateRoomDetailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerUpdate(id: string, updateRoomDetailDto: UpdateRoomDetailDto, options?: RawAxiosRequestConfig): AxiosPromise<RoomDetail> {
            return localVarFp.roomDetailControllerUpdate(id, updateRoomDetailDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomDetailsApi - object-oriented interface
 * @export
 * @class RoomDetailsApi
 * @extends {BaseAPI}
 */
export class RoomDetailsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new room detail
     * @param {CreateRoomDetailDto} createRoomDetailDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomDetailsApi
     */
    public roomDetailControllerCreate(createRoomDetailDto: CreateRoomDetailDto, options?: RawAxiosRequestConfig) {
        return RoomDetailsApiFp(this.configuration).roomDetailControllerCreate(createRoomDetailDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all room details with pagination and filters
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {object} [filters] 
     * @param {Array<string>} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomDetailsApi
     */
    public roomDetailControllerFindMany(page?: number, pageSize?: number, filters?: object, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return RoomDetailsApiFp(this.configuration).roomDetailControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a room detail by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomDetailsApi
     */
    public roomDetailControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return RoomDetailsApiFp(this.configuration).roomDetailControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a room detail
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomDetailsApi
     */
    public roomDetailControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return RoomDetailsApiFp(this.configuration).roomDetailControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a room detail
     * @param {string} id 
     * @param {UpdateRoomDetailDto} updateRoomDetailDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomDetailsApi
     */
    public roomDetailControllerUpdate(id: string, updateRoomDetailDto: UpdateRoomDetailDto, options?: RawAxiosRequestConfig) {
        return RoomDetailsApiFp(this.configuration).roomDetailControllerUpdate(id, updateRoomDetailDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterUserDto
         * @param {string} [sort] JSON string of SortUserDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetUsers: async (page?: number, pageSize?: number, filters?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterUserDto
         * @param {string} [sort] JSON string of SortUserDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetUsers(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPaginationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetUsers(page, pageSize, filters, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterUserDto
         * @param {string} [sort] JSON string of SortUserDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetUsers(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<UsersPaginationResultDto> {
            return localVarFp.usersControllerGetUsers(page, pageSize, filters, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [filters] JSON string of FilterUserDto
     * @param {string} [sort] JSON string of SortUserDto[]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetUsers(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetUsers(page, pageSize, filters, sort, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VerificationApi - axios parameter creator
 * @export
 */
export const VerificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Verify a code
         * @param {VerifyCodeDto} verifyCodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verificationControllerVerifyCode: async (verifyCodeDto: VerifyCodeDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyCodeDto' is not null or undefined
            assertParamExists('verificationControllerVerifyCode', 'verifyCodeDto', verifyCodeDto)
            const localVarPath = `/api/verification/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyCodeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VerificationApi - functional programming interface
 * @export
 */
export const VerificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VerificationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Verify a code
         * @param {VerifyCodeDto} verifyCodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verificationControllerVerifyCode(verifyCodeDto: VerifyCodeDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyCodeResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verificationControllerVerifyCode(verifyCodeDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VerificationApi.verificationControllerVerifyCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VerificationApi - factory interface
 * @export
 */
export const VerificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VerificationApiFp(configuration)
    return {
        /**
         * 
         * @summary Verify a code
         * @param {VerifyCodeDto} verifyCodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verificationControllerVerifyCode(verifyCodeDto: VerifyCodeDto, options?: RawAxiosRequestConfig): AxiosPromise<VerifyCodeResponseDto> {
            return localVarFp.verificationControllerVerifyCode(verifyCodeDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VerificationApi - object-oriented interface
 * @export
 * @class VerificationApi
 * @extends {BaseAPI}
 */
export class VerificationApi extends BaseAPI {
    /**
     * 
     * @summary Verify a code
     * @param {VerifyCodeDto} verifyCodeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public verificationControllerVerifyCode(verifyCodeDto: VerifyCodeDto, options?: RawAxiosRequestConfig) {
        return VerificationApiFp(this.configuration).verificationControllerVerifyCode(verifyCodeDto, options).then((request) => request(this.axios, this.basePath));
    }
}



