/* tslint:disable */
/* eslint-disable */
/**
 * VVintage documentation
 * This is VVintage\'s APIs description
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Branch
 */
export interface Branch {
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'updatedAt': string;
    /**
     * Branch\'s thumbnail image
     * @type {Image}
     * @memberof Branch
     */
    'thumbnail': Image;
    /**
     * Branch\'s image gallery
     * @type {Array<Image>}
     * @memberof Branch
     */
    'images': Array<Image>;
    /**
     * Branch\'s name
     * @type {string}
     * @memberof Branch
     */
    'name': string;
    /**
     * Branch\'s description
     * @type {string}
     * @memberof Branch
     */
    'description': string;
    /**
     * Branch\'s contact phone number
     * @type {string}
     * @memberof Branch
     */
    'phone': string;
    /**
     * Branch\'s active status
     * @type {boolean}
     * @memberof Branch
     */
    'is_active': boolean;
    /**
     * Branch\'s physical address
     * @type {string}
     * @memberof Branch
     */
    'address': string;
    /**
     * Branch\'s geographical location
     * @type {object}
     * @memberof Branch
     */
    'location': object;
    /**
     * Branch\'s rating
     * @type {number}
     * @memberof Branch
     */
    'rating': number;
}
/**
 * 
 * @export
 * @interface BranchesPaginationResultDto
 */
export interface BranchesPaginationResultDto {
    /**
     * 
     * @type {Array<object>}
     * @memberof BranchesPaginationResultDto
     */
    'data': Array<object>;
    /**
     * 
     * @type {UsersPaginationResultDtoMeta}
     * @memberof BranchesPaginationResultDto
     */
    'meta': UsersPaginationResultDtoMeta;
}
/**
 * 
 * @export
 * @interface CreateBranchDto
 */
export interface CreateBranchDto {
    /**
     * ID of the province where this branch is located
     * @type {string}
     * @memberof CreateBranchDto
     */
    'provinceId': string;
    /**
     * The branch\'s thumbnail image.
     * @type {Image}
     * @memberof CreateBranchDto
     */
    'thumbnail': Image;
    /**
     * The branch\'s images.
     * @type {Array<Image>}
     * @memberof CreateBranchDto
     */
    'images': Array<Image>;
    /**
     * The branch\'s name.
     * @type {string}
     * @memberof CreateBranchDto
     */
    'name': string;
    /**
     * The branch\'s description.
     * @type {string}
     * @memberof CreateBranchDto
     */
    'description': string;
    /**
     * The branch\'s phone number.
     * @type {string}
     * @memberof CreateBranchDto
     */
    'phone': string;
    /**
     * The branch\'s active status.
     * @type {boolean}
     * @memberof CreateBranchDto
     */
    'is_active': boolean;
    /**
     * The branch\'s address.
     * @type {string}
     * @memberof CreateBranchDto
     */
    'address': string;
    /**
     * Branch\'s geographical location
     * @type {LocationDto}
     * @memberof CreateBranchDto
     */
    'location': LocationDto;
    /**
     * The branch\'s rating.
     * @type {number}
     * @memberof CreateBranchDto
     */
    'rating': number;
}
/**
 * 
 * @export
 * @interface CreateProvinceDto
 */
export interface CreateProvinceDto {
    /**
     * Name of the province
     * @type {string}
     * @memberof CreateProvinceDto
     */
    'name': string;
    /**
     * ZIP/Postal code of the province
     * @type {string}
     * @memberof CreateProvinceDto
     */
    'zip_code': string;
    /**
     * URL-friendly slug of the province name
     * @type {string}
     * @memberof CreateProvinceDto
     */
    'slug': string;
}
/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * The user\'s email address.
     * @type {string}
     * @memberof CreateUserDto
     */
    'email': string;
    /**
     * The user\'s phone number.
     * @type {string}
     * @memberof CreateUserDto
     */
    'phone': string;
    /**
     * The user\'s password.
     * @type {string}
     * @memberof CreateUserDto
     */
    'password': string;
    /**
     * The user\'s name.
     * @type {string}
     * @memberof CreateUserDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * The image\'s URL.
     * @type {string}
     * @memberof Image
     */
    'url': string;
    /**
     * The image\'s public ID in Cloudinary.
     * @type {string}
     * @memberof Image
     */
    'publicId': string;
}
/**
 * 
 * @export
 * @interface ImageUploadResponseDto
 */
export interface ImageUploadResponseDto {
    /**
     * The image\'s URL.
     * @type {string}
     * @memberof ImageUploadResponseDto
     */
    'url': string;
    /**
     * The image\'s public ID in Cloudinary.
     * @type {string}
     * @memberof ImageUploadResponseDto
     */
    'publicId': string;
}
/**
 * 
 * @export
 * @interface InitiateForgotPasswordEmailDto
 */
export interface InitiateForgotPasswordEmailDto {
    /**
     * Email address of the user who forgot their password
     * @type {string}
     * @memberof InitiateForgotPasswordEmailDto
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface LocationDto
 */
export interface LocationDto {
    /**
     * Latitude coordinate
     * @type {number}
     * @memberof LocationDto
     */
    'latitude': number;
    /**
     * Longitude coordinate
     * @type {number}
     * @memberof LocationDto
     */
    'longitude': number;
}
/**
 * 
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     * The user\'s email address or phone number.
     * @type {string}
     * @memberof LoginDto
     */
    'emailOrPhone': string;
    /**
     * The user\'s password.
     * @type {string}
     * @memberof LoginDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponseDto
 */
export interface LoginResponseDto {
    /**
     * New access token
     * @type {string}
     * @memberof LoginResponseDto
     */
    'accessToken': string;
    /**
     * Timestamp when the access token expires
     * @type {number}
     * @memberof LoginResponseDto
     */
    'accessTokenExpires': number;
    /**
     * New refresh token
     * @type {string}
     * @memberof LoginResponseDto
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface LogoutResponseDto
 */
export interface LogoutResponseDto {
    /**
     * Success message
     * @type {string}
     * @memberof LogoutResponseDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface Province
 */
export interface Province {
    /**
     * 
     * @type {string}
     * @memberof Province
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Province
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Province
     */
    'updatedAt': string;
    /**
     * Name of the province
     * @type {string}
     * @memberof Province
     */
    'name': string;
    /**
     * ZIP/Postal code of the province
     * @type {string}
     * @memberof Province
     */
    'zip_code': string;
    /**
     * Slug of the province
     * @type {string}
     * @memberof Province
     */
    'slug': string;
}
/**
 * 
 * @export
 * @interface ProvincePaginationResultDto
 */
export interface ProvincePaginationResultDto {
    /**
     * 
     * @type {Array<object>}
     * @memberof ProvincePaginationResultDto
     */
    'data': Array<object>;
    /**
     * 
     * @type {UsersPaginationResultDtoMeta}
     * @memberof ProvincePaginationResultDto
     */
    'meta': UsersPaginationResultDtoMeta;
}
/**
 * 
 * @export
 * @interface RefreshTokenDto
 */
export interface RefreshTokenDto {
    /**
     * The refresh token to renew access
     * @type {string}
     * @memberof RefreshTokenDto
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface RefreshTokenResponseDto
 */
export interface RefreshTokenResponseDto {
    /**
     * New access token
     * @type {string}
     * @memberof RefreshTokenResponseDto
     */
    'accessToken': string;
    /**
     * Timestamp when the access token expires
     * @type {number}
     * @memberof RefreshTokenResponseDto
     */
    'accessTokenExpires': number;
    /**
     * New refresh token
     * @type {string}
     * @memberof RefreshTokenResponseDto
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface RegisterDto
 */
export interface RegisterDto {
    /**
     * 
     * @type {CreateUserDto}
     * @memberof RegisterDto
     */
    'data': CreateUserDto;
    /**
     * 
     * @type {string}
     * @memberof RegisterDto
     */
    'accountIdentifier': RegisterDtoAccountIdentifierEnum;
}

export const RegisterDtoAccountIdentifierEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE'
} as const;

export type RegisterDtoAccountIdentifierEnum = typeof RegisterDtoAccountIdentifierEnum[keyof typeof RegisterDtoAccountIdentifierEnum];

/**
 * 
 * @export
 * @interface RegisterResponseDto
 */
export interface RegisterResponseDto {
    /**
     * The user\'s email address
     * @type {string}
     * @memberof RegisterResponseDto
     */
    'email'?: string;
    /**
     * The user\'s phone number
     * @type {string}
     * @memberof RegisterResponseDto
     */
    'phone'?: string;
    /**
     * The type of identifier used for registration
     * @type {string}
     * @memberof RegisterResponseDto
     */
    'identifier_type': RegisterResponseDtoIdentifierTypeEnum;
}

export const RegisterResponseDtoIdentifierTypeEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE'
} as const;

export type RegisterResponseDtoIdentifierTypeEnum = typeof RegisterResponseDtoIdentifierTypeEnum[keyof typeof RegisterResponseDtoIdentifierTypeEnum];

/**
 * 
 * @export
 * @interface ResetPasswordWithOTPEmailDto
 */
export interface ResetPasswordWithOTPEmailDto {
    /**
     * Email address of the user
     * @type {string}
     * @memberof ResetPasswordWithOTPEmailDto
     */
    'email': string;
    /**
     * Six digit verification code sent to email
     * @type {string}
     * @memberof ResetPasswordWithOTPEmailDto
     */
    'code': string;
    /**
     * New password to set
     * @type {string}
     * @memberof ResetPasswordWithOTPEmailDto
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface RevokeSessionResponseDto
 */
export interface RevokeSessionResponseDto {
    /**
     * Success message
     * @type {string}
     * @memberof RevokeSessionResponseDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface SessionResponseDto
 */
export interface SessionResponseDto {
    /**
     * List of active user sessions
     * @type {Array<string>}
     * @memberof SessionResponseDto
     */
    'sessions': Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateBranchDto
 */
export interface UpdateBranchDto {
    /**
     * ID of the province where this branch is located
     * @type {string}
     * @memberof UpdateBranchDto
     */
    'provinceId'?: string;
    /**
     * The branch\'s thumbnail image.
     * @type {Image}
     * @memberof UpdateBranchDto
     */
    'thumbnail'?: Image;
    /**
     * The branch\'s images.
     * @type {Array<Image>}
     * @memberof UpdateBranchDto
     */
    'images'?: Array<Image>;
    /**
     * The branch\'s name.
     * @type {string}
     * @memberof UpdateBranchDto
     */
    'name'?: string;
    /**
     * The branch\'s description.
     * @type {string}
     * @memberof UpdateBranchDto
     */
    'description'?: string;
    /**
     * The branch\'s phone number.
     * @type {string}
     * @memberof UpdateBranchDto
     */
    'phone'?: string;
    /**
     * The branch\'s active status.
     * @type {boolean}
     * @memberof UpdateBranchDto
     */
    'is_active'?: boolean;
    /**
     * The branch\'s address.
     * @type {string}
     * @memberof UpdateBranchDto
     */
    'address'?: string;
    /**
     * Branch\'s geographical location
     * @type {LocationDto}
     * @memberof UpdateBranchDto
     */
    'location'?: LocationDto;
    /**
     * The branch\'s rating.
     * @type {number}
     * @memberof UpdateBranchDto
     */
    'rating'?: number;
}
/**
 * 
 * @export
 * @interface UpdateProvinceDto
 */
export interface UpdateProvinceDto {
    /**
     * Name of the province
     * @type {string}
     * @memberof UpdateProvinceDto
     */
    'name'?: string;
    /**
     * ZIP/Postal code of the province
     * @type {string}
     * @memberof UpdateProvinceDto
     */
    'zip_code'?: string;
    /**
     * URL-friendly slug of the province name
     * @type {string}
     * @memberof UpdateProvinceDto
     */
    'slug'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phone': string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'verified_email': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'verified_phone': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'identifier_type': UserIdentifierTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_blocked': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role': UserRoleEnum;
}

export const UserIdentifierTypeEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE'
} as const;

export type UserIdentifierTypeEnum = typeof UserIdentifierTypeEnum[keyof typeof UserIdentifierTypeEnum];
export const UserRoleEnum = {
    User: 'USER',
    Staff: 'STAFF',
    Admin: 'ADMIN'
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];

/**
 * 
 * @export
 * @interface UsersPaginationResultDto
 */
export interface UsersPaginationResultDto {
    /**
     * 
     * @type {Array<User>}
     * @memberof UsersPaginationResultDto
     */
    'data': Array<User>;
    /**
     * 
     * @type {UsersPaginationResultDtoMeta}
     * @memberof UsersPaginationResultDto
     */
    'meta': UsersPaginationResultDtoMeta;
}
/**
 * 
 * @export
 * @interface UsersPaginationResultDtoMeta
 */
export interface UsersPaginationResultDtoMeta {
    /**
     * 
     * @type {number}
     * @memberof UsersPaginationResultDtoMeta
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof UsersPaginationResultDtoMeta
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof UsersPaginationResultDtoMeta
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof UsersPaginationResultDtoMeta
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface VerificationEmailDto
 */
export interface VerificationEmailDto {
    /**
     * Email address to send verification code
     * @type {string}
     * @memberof VerificationEmailDto
     */
    'to': string;
    /**
     * Verification code to be sent
     * @type {string}
     * @memberof VerificationEmailDto
     */
    'code': string;
    /**
     * Language for email template
     * @type {string}
     * @memberof VerificationEmailDto
     */
    'lang'?: VerificationEmailDtoLangEnum;
    /**
     * Type of verification email
     * @type {string}
     * @memberof VerificationEmailDto
     */
    'type': VerificationEmailDtoTypeEnum;
}

export const VerificationEmailDtoLangEnum = {
    En: 'en',
    Vi: 'vi'
} as const;

export type VerificationEmailDtoLangEnum = typeof VerificationEmailDtoLangEnum[keyof typeof VerificationEmailDtoLangEnum];
export const VerificationEmailDtoTypeEnum = {
    VerifyAccount: 'VERIFY_ACCOUNT',
    ForgotPassword: 'FORGOT_PASSWORD'
} as const;

export type VerificationEmailDtoTypeEnum = typeof VerificationEmailDtoTypeEnum[keyof typeof VerificationEmailDtoTypeEnum];

/**
 * 
 * @export
 * @interface VerifyCodeDto
 */
export interface VerifyCodeDto {
    /**
     * User ID
     * @type {string}
     * @memberof VerifyCodeDto
     */
    'userId': string;
    /**
     * Account type
     * @type {string}
     * @memberof VerifyCodeDto
     */
    'type': string;
    /**
     * Verification code
     * @type {string}
     * @memberof VerifyCodeDto
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface VerifyCodeResponseDto
 */
export interface VerifyCodeResponseDto {
    /**
     * Verification status
     * @type {boolean}
     * @memberof VerifyCodeResponseDto
     */
    'success': boolean;
    /**
     * User ID
     * @type {string}
     * @memberof VerifyCodeResponseDto
     */
    'userId': string;
    /**
     * Type of verification
     * @type {string}
     * @memberof VerifyCodeResponseDto
     */
    'type': VerifyCodeResponseDtoTypeEnum;
}

export const VerifyCodeResponseDtoTypeEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE'
} as const;

export type VerifyCodeResponseDtoTypeEnum = typeof VerifyCodeResponseDtoTypeEnum[keyof typeof VerifyCodeResponseDtoTypeEnum];

/**
 * 
 * @export
 * @interface VerifyEmailDto
 */
export interface VerifyEmailDto {
    /**
     * User ID
     * @type {string}
     * @memberof VerifyEmailDto
     */
    'userId': string;
    /**
     * Verification code sent to email
     * @type {string}
     * @memberof VerifyEmailDto
     */
    'code': string;
}

/**
 * AmenitiesApi - axios parameter creator
 * @export
 */
export const AmenitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {AmenitiesControllerCreateTypeEnum} [type] 
         * @param {File} [icon] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerCreate: async (name?: string, slug?: string, type?: AmenitiesControllerCreateTypeEnum, icon?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/amenities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (slug !== undefined) { 
                localVarFormParams.append('slug', slug as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.append('type', type as any);
            }
    
            if (icon !== undefined) { 
                localVarFormParams.append('icon', icon as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string
         * @param {string} [sort] JSON string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerFindAll: async (page?: number, pageSize?: number, filters?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/amenities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('amenitiesControllerFindOne', 'id', id)
            const localVarPath = `/api/amenities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('amenitiesControllerRemove', 'id', id)
            const localVarPath = `/api/amenities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [name] The name of the amenity
         * @param {string} [slug] URL-friendly version of the name (lowercase, hyphenated)
         * @param {AmenitiesControllerUpdateTypeEnum} [type] Type of amenity (ROOM, PROPERTY, or SERVICE)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerUpdate: async (id: string, name?: string, slug?: string, type?: AmenitiesControllerUpdateTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('amenitiesControllerUpdate', 'id', id)
            const localVarPath = `/api/amenities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (slug !== undefined) { 
                localVarFormParams.append('slug', slug as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.append('type', type as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AmenitiesApi - functional programming interface
 * @export
 */
export const AmenitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AmenitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {AmenitiesControllerCreateTypeEnum} [type] 
         * @param {File} [icon] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async amenitiesControllerCreate(name?: string, slug?: string, type?: AmenitiesControllerCreateTypeEnum, icon?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.amenitiesControllerCreate(name, slug, type, icon, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AmenitiesApi.amenitiesControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string
         * @param {string} [sort] JSON string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async amenitiesControllerFindAll(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.amenitiesControllerFindAll(page, pageSize, filters, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AmenitiesApi.amenitiesControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async amenitiesControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.amenitiesControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AmenitiesApi.amenitiesControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async amenitiesControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.amenitiesControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AmenitiesApi.amenitiesControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [name] The name of the amenity
         * @param {string} [slug] URL-friendly version of the name (lowercase, hyphenated)
         * @param {AmenitiesControllerUpdateTypeEnum} [type] Type of amenity (ROOM, PROPERTY, or SERVICE)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async amenitiesControllerUpdate(id: string, name?: string, slug?: string, type?: AmenitiesControllerUpdateTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.amenitiesControllerUpdate(id, name, slug, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AmenitiesApi.amenitiesControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AmenitiesApi - factory interface
 * @export
 */
export const AmenitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AmenitiesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {AmenitiesControllerCreateTypeEnum} [type] 
         * @param {File} [icon] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerCreate(name?: string, slug?: string, type?: AmenitiesControllerCreateTypeEnum, icon?: File, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.amenitiesControllerCreate(name, slug, type, icon, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string
         * @param {string} [sort] JSON string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerFindAll(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.amenitiesControllerFindAll(page, pageSize, filters, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.amenitiesControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.amenitiesControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [name] The name of the amenity
         * @param {string} [slug] URL-friendly version of the name (lowercase, hyphenated)
         * @param {AmenitiesControllerUpdateTypeEnum} [type] Type of amenity (ROOM, PROPERTY, or SERVICE)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerUpdate(id: string, name?: string, slug?: string, type?: AmenitiesControllerUpdateTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.amenitiesControllerUpdate(id, name, slug, type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AmenitiesApi - object-oriented interface
 * @export
 * @class AmenitiesApi
 * @extends {BaseAPI}
 */
export class AmenitiesApi extends BaseAPI {
    /**
     * 
     * @param {string} [name] 
     * @param {string} [slug] 
     * @param {AmenitiesControllerCreateTypeEnum} [type] 
     * @param {File} [icon] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmenitiesApi
     */
    public amenitiesControllerCreate(name?: string, slug?: string, type?: AmenitiesControllerCreateTypeEnum, icon?: File, options?: RawAxiosRequestConfig) {
        return AmenitiesApiFp(this.configuration).amenitiesControllerCreate(name, slug, type, icon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [filters] JSON string
     * @param {string} [sort] JSON string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmenitiesApi
     */
    public amenitiesControllerFindAll(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return AmenitiesApiFp(this.configuration).amenitiesControllerFindAll(page, pageSize, filters, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmenitiesApi
     */
    public amenitiesControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return AmenitiesApiFp(this.configuration).amenitiesControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmenitiesApi
     */
    public amenitiesControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return AmenitiesApiFp(this.configuration).amenitiesControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [name] The name of the amenity
     * @param {string} [slug] URL-friendly version of the name (lowercase, hyphenated)
     * @param {AmenitiesControllerUpdateTypeEnum} [type] Type of amenity (ROOM, PROPERTY, or SERVICE)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmenitiesApi
     */
    public amenitiesControllerUpdate(id: string, name?: string, slug?: string, type?: AmenitiesControllerUpdateTypeEnum, options?: RawAxiosRequestConfig) {
        return AmenitiesApiFp(this.configuration).amenitiesControllerUpdate(id, name, slug, type, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AmenitiesControllerCreateTypeEnum = {
    Room: 'ROOM',
    Property: 'PROPERTY',
    Service: 'SERVICE'
} as const;
export type AmenitiesControllerCreateTypeEnum = typeof AmenitiesControllerCreateTypeEnum[keyof typeof AmenitiesControllerCreateTypeEnum];
/**
 * @export
 */
export const AmenitiesControllerUpdateTypeEnum = {
    Room: 'ROOM',
    Property: 'PROPERTY',
    Service: 'SERVICE'
} as const;
export type AmenitiesControllerUpdateTypeEnum = typeof AmenitiesControllerUpdateTypeEnum[keyof typeof AmenitiesControllerUpdateTypeEnum];


/**
 * AppApi - axios parameter creator
 * @export
 */
export const AppApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppApi - functional programming interface
 * @export
 */
export const AppApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerGetHello(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetHello(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppApi.appControllerGetHello']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AppApi - factory interface
 * @export
 */
export const AppApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.appControllerGetHello(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppApi - object-oriented interface
 * @export
 * @class AppApi
 * @extends {BaseAPI}
 */
export class AppApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppApi
     */
    public appControllerGetHello(options?: RawAxiosRequestConfig) {
        return AppApiFp(this.configuration).appControllerGetHello(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all active sessions for the current user
         * @summary Get active sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetActiveSessions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get analytics data for user sessions. Requires ADMIN role.
         * @summary Get session analytics
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetSessionAnalytics: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('authControllerGetSessionAnalytics', 'userId', userId)
            const localVarPath = `/api/auth/sessions/analytics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get suspicious activities for a specific user. Requires ADMIN role.
         * @summary Get suspicious activities
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetSuspiciousActivities: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('authControllerGetSuspiciousActivities', 'userId', userId)
            const localVarPath = `/api/auth/users/{userId}/suspicious-activities`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate forgot password process
         * @param {InitiateForgotPasswordEmailDto} initiateForgotPasswordEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerInitiateForgotPassword: async (initiateForgotPasswordEmailDto: InitiateForgotPasswordEmailDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'initiateForgotPasswordEmailDto' is not null or undefined
            assertParamExists('authControllerInitiateForgotPassword', 'initiateForgotPasswordEmailDto', initiateForgotPasswordEmailDto)
            const localVarPath = `/api/auth/forgot-password/email/initiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(initiateForgotPasswordEmailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userAgent 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (userAgent: string, loginDto: LoginDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAgent' is not null or undefined
            assertParamExists('authControllerLogin', 'userAgent', userAgent)
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('authControllerLogin', 'loginDto', loginDto)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (userAgent != null) {
                localVarHeaderParameter['user-agent'] = String(userAgent);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke the current refresh token, effectively logging out the user
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exchange a valid refresh token for a new access token and refresh token pair
         * @summary Refresh access token
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshTokens: async (refreshTokenDto: RefreshTokenDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenDto' is not null or undefined
            assertParamExists('authControllerRefreshTokens', 'refreshTokenDto', refreshTokenDto)
            const localVarPath = `/api/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister: async (registerDto: RegisterDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerDto' is not null or undefined
            assertParamExists('authControllerRegister', 'registerDto', registerDto)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset password using OTP
         * @param {ResetPasswordWithOTPEmailDto} resetPasswordWithOTPEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPasswordWithOTP: async (resetPasswordWithOTPEmailDto: ResetPasswordWithOTPEmailDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordWithOTPEmailDto' is not null or undefined
            assertParamExists('authControllerResetPasswordWithOTP', 'resetPasswordWithOTPEmailDto', resetPasswordWithOTPEmailDto)
            const localVarPath = `/api/auth/forgot-password/email/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordWithOTPEmailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke a specific session by its ID
         * @summary Revoke specific session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRevokeSession: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('authControllerRevokeSession', 'sessionId', sessionId)
            const localVarPath = `/api/auth/sessions/{sessionId}/revoke`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify email with OTP code
         * @param {VerifyEmailDto} verifyEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyEmail: async (verifyEmailDto: VerifyEmailDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyEmailDto' is not null or undefined
            assertParamExists('authControllerVerifyEmail', 'verifyEmailDto', verifyEmailDto)
            const localVarPath = `/api/auth/verify-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyEmailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all active sessions for the current user
         * @summary Get active sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetActiveSessions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetActiveSessions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetActiveSessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get analytics data for user sessions. Requires ADMIN role.
         * @summary Get session analytics
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetSessionAnalytics(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetSessionAnalytics(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetSessionAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get suspicious activities for a specific user. Requires ADMIN role.
         * @summary Get suspicious activities
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetSuspiciousActivities(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetSuspiciousActivities(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetSuspiciousActivities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Initiate forgot password process
         * @param {InitiateForgotPasswordEmailDto} initiateForgotPasswordEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerInitiateForgotPassword(initiateForgotPasswordEmailDto: InitiateForgotPasswordEmailDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerInitiateForgotPassword(initiateForgotPasswordEmailDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerInitiateForgotPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userAgent 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(userAgent: string, loginDto: LoginDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(userAgent, loginDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke the current refresh token, effectively logging out the user
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogoutResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exchange a valid refresh token for a new access token and refresh token pair
         * @summary Refresh access token
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefreshTokens(refreshTokenDto: RefreshTokenDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefreshTokens(refreshTokenDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerRefreshTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRegister(registerDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset password using OTP
         * @param {ResetPasswordWithOTPEmailDto} resetPasswordWithOTPEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerResetPasswordWithOTP(resetPasswordWithOTPEmailDto: ResetPasswordWithOTPEmailDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerResetPasswordWithOTP(resetPasswordWithOTPEmailDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerResetPasswordWithOTP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke a specific session by its ID
         * @summary Revoke specific session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRevokeSession(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RevokeSessionResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRevokeSession(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerRevokeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify email with OTP code
         * @param {VerifyEmailDto} verifyEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerVerifyEmail(verifyEmailDto: VerifyEmailDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerVerifyEmail(verifyEmailDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerVerifyEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Retrieve all active sessions for the current user
         * @summary Get active sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetActiveSessions(options?: RawAxiosRequestConfig): AxiosPromise<SessionResponseDto> {
            return localVarFp.authControllerGetActiveSessions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.authControllerGetProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * Get analytics data for user sessions. Requires ADMIN role.
         * @summary Get session analytics
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetSessionAnalytics(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerGetSessionAnalytics(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get suspicious activities for a specific user. Requires ADMIN role.
         * @summary Get suspicious activities
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetSuspiciousActivities(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerGetSuspiciousActivities(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initiate forgot password process
         * @param {InitiateForgotPasswordEmailDto} initiateForgotPasswordEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerInitiateForgotPassword(initiateForgotPasswordEmailDto: InitiateForgotPasswordEmailDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerInitiateForgotPassword(initiateForgotPasswordEmailDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userAgent 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(userAgent: string, loginDto: LoginDto, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponseDto> {
            return localVarFp.authControllerLogin(userAgent, loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke the current refresh token, effectively logging out the user
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout(options?: RawAxiosRequestConfig): AxiosPromise<LogoutResponseDto> {
            return localVarFp.authControllerLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * Exchange a valid refresh token for a new access token and refresh token pair
         * @summary Refresh access token
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshTokens(refreshTokenDto: RefreshTokenDto, options?: RawAxiosRequestConfig): AxiosPromise<RefreshTokenResponseDto> {
            return localVarFp.authControllerRefreshTokens(refreshTokenDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig): AxiosPromise<RegisterResponseDto> {
            return localVarFp.authControllerRegister(registerDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset password using OTP
         * @param {ResetPasswordWithOTPEmailDto} resetPasswordWithOTPEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPasswordWithOTP(resetPasswordWithOTPEmailDto: ResetPasswordWithOTPEmailDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerResetPasswordWithOTP(resetPasswordWithOTPEmailDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke a specific session by its ID
         * @summary Revoke specific session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRevokeSession(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<RevokeSessionResponseDto> {
            return localVarFp.authControllerRevokeSession(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify email with OTP code
         * @param {VerifyEmailDto} verifyEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyEmail(verifyEmailDto: VerifyEmailDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerVerifyEmail(verifyEmailDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Retrieve all active sessions for the current user
     * @summary Get active sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetActiveSessions(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetActiveSessions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetProfile(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get analytics data for user sessions. Requires ADMIN role.
     * @summary Get session analytics
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetSessionAnalytics(userId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetSessionAnalytics(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get suspicious activities for a specific user. Requires ADMIN role.
     * @summary Get suspicious activities
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetSuspiciousActivities(userId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetSuspiciousActivities(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initiate forgot password process
     * @param {InitiateForgotPasswordEmailDto} initiateForgotPasswordEmailDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerInitiateForgotPassword(initiateForgotPasswordEmailDto: InitiateForgotPasswordEmailDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerInitiateForgotPassword(initiateForgotPasswordEmailDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userAgent 
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogin(userAgent: string, loginDto: LoginDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogin(userAgent, loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke the current refresh token, effectively logging out the user
     * @summary Logout user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogout(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exchange a valid refresh token for a new access token and refresh token pair
     * @summary Refresh access token
     * @param {RefreshTokenDto} refreshTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRefreshTokens(refreshTokenDto: RefreshTokenDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRefreshTokens(refreshTokenDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterDto} registerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRegister(registerDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset password using OTP
     * @param {ResetPasswordWithOTPEmailDto} resetPasswordWithOTPEmailDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerResetPasswordWithOTP(resetPasswordWithOTPEmailDto: ResetPasswordWithOTPEmailDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerResetPasswordWithOTP(resetPasswordWithOTPEmailDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke a specific session by its ID
     * @summary Revoke specific session
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRevokeSession(sessionId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRevokeSession(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify email with OTP code
     * @param {VerifyEmailDto} verifyEmailDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerVerifyEmail(verifyEmailDto: VerifyEmailDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerVerifyEmail(verifyEmailDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BranchesApi - axios parameter creator
 * @export
 */
export const BranchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new branch
         * @param {CreateBranchDto} createBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerCreate: async (createBranchDto: CreateBranchDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBranchDto' is not null or undefined
            assertParamExists('branchControllerCreate', 'createBranchDto', createBranchDto)
            const localVarPath = `/api/branch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBranchDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all branches with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string
         * @param {string} [sort] JSON string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindMany: async (page?: number, pageSize?: number, filters?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/branch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get branches with infinite scroll for client app
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string
         * @param {string} [sort] JSON string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindManyInfinite: async (page?: number, pageSize?: number, filters?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/branch/infinite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get branch by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('branchControllerFindOne', 'id', id)
            const localVarPath = `/api/branch/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a branch
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('branchControllerRemove', 'id', id)
            const localVarPath = `/api/branch/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a branch
         * @param {string} id 
         * @param {UpdateBranchDto} updateBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerUpdate: async (id: string, updateBranchDto: UpdateBranchDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('branchControllerUpdate', 'id', id)
            // verify required parameter 'updateBranchDto' is not null or undefined
            assertParamExists('branchControllerUpdate', 'updateBranchDto', updateBranchDto)
            const localVarPath = `/api/branch/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBranchDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BranchesApi - functional programming interface
 * @export
 */
export const BranchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BranchesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new branch
         * @param {CreateBranchDto} createBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerCreate(createBranchDto: CreateBranchDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerCreate(createBranchDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all branches with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string
         * @param {string} [sort] JSON string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchesPaginationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerFindMany(page, pageSize, filters, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get branches with infinite scroll for client app
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string
         * @param {string} [sort] JSON string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerFindManyInfinite(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Branch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerFindManyInfinite(page, pageSize, filters, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerFindManyInfinite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get branch by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a branch
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a branch
         * @param {string} id 
         * @param {UpdateBranchDto} updateBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerUpdate(id: string, updateBranchDto: UpdateBranchDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerUpdate(id, updateBranchDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BranchesApi - factory interface
 * @export
 */
export const BranchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BranchesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new branch
         * @param {CreateBranchDto} createBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerCreate(createBranchDto: CreateBranchDto, options?: RawAxiosRequestConfig): AxiosPromise<Branch> {
            return localVarFp.branchControllerCreate(createBranchDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all branches with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string
         * @param {string} [sort] JSON string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<BranchesPaginationResultDto> {
            return localVarFp.branchControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get branches with infinite scroll for client app
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string
         * @param {string} [sort] JSON string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindManyInfinite(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Branch>> {
            return localVarFp.branchControllerFindManyInfinite(page, pageSize, filters, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get branch by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Branch> {
            return localVarFp.branchControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a branch
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.branchControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a branch
         * @param {string} id 
         * @param {UpdateBranchDto} updateBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerUpdate(id: string, updateBranchDto: UpdateBranchDto, options?: RawAxiosRequestConfig): AxiosPromise<Branch> {
            return localVarFp.branchControllerUpdate(id, updateBranchDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BranchesApi - object-oriented interface
 * @export
 * @class BranchesApi
 * @extends {BaseAPI}
 */
export class BranchesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new branch
     * @param {CreateBranchDto} createBranchDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerCreate(createBranchDto: CreateBranchDto, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerCreate(createBranchDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all branches with pagination and filters
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [filters] JSON string
     * @param {string} [sort] JSON string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get branches with infinite scroll for client app
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [filters] JSON string
     * @param {string} [sort] JSON string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerFindManyInfinite(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerFindManyInfinite(page, pageSize, filters, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get branch by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a branch
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a branch
     * @param {string} id 
     * @param {UpdateBranchDto} updateBranchDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerUpdate(id: string, updateBranchDto: UpdateBranchDto, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerUpdate(id, updateBranchDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EmailApi - axios parameter creator
 * @export
 */
export const EmailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send verification email
         * @param {VerificationEmailDto} verificationEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailControllerSendVerificationEmail: async (verificationEmailDto: VerificationEmailDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verificationEmailDto' is not null or undefined
            assertParamExists('emailControllerSendVerificationEmail', 'verificationEmailDto', verificationEmailDto)
            const localVarPath = `/api/email/send-verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verificationEmailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailApi - functional programming interface
 * @export
 */
export const EmailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmailApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Send verification email
         * @param {VerificationEmailDto} verificationEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailControllerSendVerificationEmail(verificationEmailDto: VerificationEmailDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailControllerSendVerificationEmail(verificationEmailDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmailApi.emailControllerSendVerificationEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EmailApi - factory interface
 * @export
 */
export const EmailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmailApiFp(configuration)
    return {
        /**
         * 
         * @summary Send verification email
         * @param {VerificationEmailDto} verificationEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailControllerSendVerificationEmail(verificationEmailDto: VerificationEmailDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.emailControllerSendVerificationEmail(verificationEmailDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmailApi - object-oriented interface
 * @export
 * @class EmailApi
 * @extends {BaseAPI}
 */
export class EmailApi extends BaseAPI {
    /**
     * 
     * @summary Send verification email
     * @param {VerificationEmailDto} verificationEmailDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApi
     */
    public emailControllerSendVerificationEmail(verificationEmailDto: VerificationEmailDto, options?: RawAxiosRequestConfig) {
        return EmailApiFp(this.configuration).emailControllerSendVerificationEmail(verificationEmailDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get image by public id
         * @param {string} publicId Public ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetImageByPublicId: async (publicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicId' is not null or undefined
            assertParamExists('imagesControllerGetImageByPublicId', 'publicId', publicId)
            const localVarPath = `/api/images/{publicId}`
                .replace(`{${"publicId"}}`, encodeURIComponent(String(publicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerUploadImages: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get image by public id
         * @param {string} publicId Public ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerGetImageByPublicId(publicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerGetImageByPublicId(publicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerGetImageByPublicId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerUploadImages(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerUploadImages(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerUploadImages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get image by public id
         * @param {string} publicId Public ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetImageByPublicId(publicId: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadResponseDto> {
            return localVarFp.imagesControllerGetImageByPublicId(publicId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerUploadImages(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.imagesControllerUploadImages(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
    /**
     * 
     * @summary Get image by public id
     * @param {string} publicId Public ID of the image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerGetImageByPublicId(publicId: string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerGetImageByPublicId(publicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerUploadImages(options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerUploadImages(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProvincesApi - axios parameter creator
 * @export
 */
export const ProvincesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new province
         * @param {CreateProvinceDto} createProvinceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerCreate: async (createProvinceDto: CreateProvinceDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProvinceDto' is not null or undefined
            assertParamExists('provincesControllerCreate', 'createProvinceDto', createProvinceDto)
            const localVarPath = `/api/provinces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProvinceDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all provinces with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string
         * @param {string} [sort] JSON string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerFindMany: async (page?: number, pageSize?: number, filters?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/provinces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get province by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('provincesControllerFindOne', 'id', id)
            const localVarPath = `/api/provinces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a province
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('provincesControllerRemove', 'id', id)
            const localVarPath = `/api/provinces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a province
         * @param {string} id 
         * @param {UpdateProvinceDto} updateProvinceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerUpdate: async (id: string, updateProvinceDto: UpdateProvinceDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('provincesControllerUpdate', 'id', id)
            // verify required parameter 'updateProvinceDto' is not null or undefined
            assertParamExists('provincesControllerUpdate', 'updateProvinceDto', updateProvinceDto)
            const localVarPath = `/api/provinces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProvinceDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvincesApi - functional programming interface
 * @export
 */
export const ProvincesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProvincesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new province
         * @param {CreateProvinceDto} createProvinceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provincesControllerCreate(createProvinceDto: CreateProvinceDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Province>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provincesControllerCreate(createProvinceDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvincesApi.provincesControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all provinces with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string
         * @param {string} [sort] JSON string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provincesControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvincePaginationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provincesControllerFindMany(page, pageSize, filters, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvincesApi.provincesControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get province by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provincesControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Province>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provincesControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvincesApi.provincesControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a province
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provincesControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provincesControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvincesApi.provincesControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a province
         * @param {string} id 
         * @param {UpdateProvinceDto} updateProvinceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provincesControllerUpdate(id: string, updateProvinceDto: UpdateProvinceDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Province>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provincesControllerUpdate(id, updateProvinceDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvincesApi.provincesControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProvincesApi - factory interface
 * @export
 */
export const ProvincesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProvincesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new province
         * @param {CreateProvinceDto} createProvinceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerCreate(createProvinceDto: CreateProvinceDto, options?: RawAxiosRequestConfig): AxiosPromise<Province> {
            return localVarFp.provincesControllerCreate(createProvinceDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all provinces with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string
         * @param {string} [sort] JSON string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProvincePaginationResultDto> {
            return localVarFp.provincesControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get province by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Province> {
            return localVarFp.provincesControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a province
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.provincesControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a province
         * @param {string} id 
         * @param {UpdateProvinceDto} updateProvinceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerUpdate(id: string, updateProvinceDto: UpdateProvinceDto, options?: RawAxiosRequestConfig): AxiosPromise<Province> {
            return localVarFp.provincesControllerUpdate(id, updateProvinceDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvincesApi - object-oriented interface
 * @export
 * @class ProvincesApi
 * @extends {BaseAPI}
 */
export class ProvincesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new province
     * @param {CreateProvinceDto} createProvinceDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvincesApi
     */
    public provincesControllerCreate(createProvinceDto: CreateProvinceDto, options?: RawAxiosRequestConfig) {
        return ProvincesApiFp(this.configuration).provincesControllerCreate(createProvinceDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all provinces with pagination and filters
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [filters] JSON string
     * @param {string} [sort] JSON string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvincesApi
     */
    public provincesControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return ProvincesApiFp(this.configuration).provincesControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get province by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvincesApi
     */
    public provincesControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return ProvincesApiFp(this.configuration).provincesControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a province
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvincesApi
     */
    public provincesControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return ProvincesApiFp(this.configuration).provincesControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a province
     * @param {string} id 
     * @param {UpdateProvinceDto} updateProvinceDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvincesApi
     */
    public provincesControllerUpdate(id: string, updateProvinceDto: UpdateProvinceDto, options?: RawAxiosRequestConfig) {
        return ProvincesApiFp(this.configuration).provincesControllerUpdate(id, updateProvinceDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterUserDto
         * @param {string} [sort] JSON string of SortUserDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetUsers: async (page?: number, pageSize?: number, filters?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterUserDto
         * @param {string} [sort] JSON string of SortUserDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetUsers(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPaginationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetUsers(page, pageSize, filters, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterUserDto
         * @param {string} [sort] JSON string of SortUserDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetUsers(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<UsersPaginationResultDto> {
            return localVarFp.usersControllerGetUsers(page, pageSize, filters, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [filters] JSON string of FilterUserDto
     * @param {string} [sort] JSON string of SortUserDto[]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetUsers(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetUsers(page, pageSize, filters, sort, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VerificationApi - axios parameter creator
 * @export
 */
export const VerificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Verify a code
         * @param {VerifyCodeDto} verifyCodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verificationControllerVerifyCode: async (verifyCodeDto: VerifyCodeDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyCodeDto' is not null or undefined
            assertParamExists('verificationControllerVerifyCode', 'verifyCodeDto', verifyCodeDto)
            const localVarPath = `/api/verification/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyCodeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VerificationApi - functional programming interface
 * @export
 */
export const VerificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VerificationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Verify a code
         * @param {VerifyCodeDto} verifyCodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verificationControllerVerifyCode(verifyCodeDto: VerifyCodeDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyCodeResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verificationControllerVerifyCode(verifyCodeDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VerificationApi.verificationControllerVerifyCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VerificationApi - factory interface
 * @export
 */
export const VerificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VerificationApiFp(configuration)
    return {
        /**
         * 
         * @summary Verify a code
         * @param {VerifyCodeDto} verifyCodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verificationControllerVerifyCode(verifyCodeDto: VerifyCodeDto, options?: RawAxiosRequestConfig): AxiosPromise<VerifyCodeResponseDto> {
            return localVarFp.verificationControllerVerifyCode(verifyCodeDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VerificationApi - object-oriented interface
 * @export
 * @class VerificationApi
 * @extends {BaseAPI}
 */
export class VerificationApi extends BaseAPI {
    /**
     * 
     * @summary Verify a code
     * @param {VerifyCodeDto} verifyCodeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public verificationControllerVerifyCode(verifyCodeDto: VerifyCodeDto, options?: RawAxiosRequestConfig) {
        return VerificationApiFp(this.configuration).verificationControllerVerifyCode(verifyCodeDto, options).then((request) => request(this.axios, this.basePath));
    }
}



