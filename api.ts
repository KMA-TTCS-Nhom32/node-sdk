/* tslint:disable */
/* eslint-disable */
/**
 * VVintage documentation
 * This is VVintage\'s APIs description
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddTranslationDto
 */
export interface AddTranslationDto {
    /**
     * The language code for the translations
     * @type {string}
     * @memberof AddTranslationDto
     */
    'language': string;
    /**
     * Array of translations to add
     * @type {Array<TranslationData>}
     * @memberof AddTranslationDto
     */
    'data': Array<TranslationData>;
}
/**
 * 
 * @export
 * @interface AdminUpdateUserDto
 */
export interface AdminUpdateUserDto {
    /**
     * The user\'s role.
     * @type {string}
     * @memberof AdminUpdateUserDto
     */
    'role': AdminUpdateUserDtoRoleEnum;
    /**
     * Filter by branch ID
     * @type {string}
     * @memberof AdminUpdateUserDto
     */
    'branchId'?: string;
}

export const AdminUpdateUserDtoRoleEnum = {
    User: 'USER',
    Staff: 'STAFF',
    Admin: 'ADMIN'
} as const;

export type AdminUpdateUserDtoRoleEnum = typeof AdminUpdateUserDtoRoleEnum[keyof typeof AdminUpdateUserDtoRoleEnum];

/**
 * 
 * @export
 * @interface AmenitiesPaginationResultDto
 */
export interface AmenitiesPaginationResultDto {
    /**
     * 
     * @type {Array<Amenity>}
     * @memberof AmenitiesPaginationResultDto
     */
    'data': Array<Amenity>;
    /**
     * 
     * @type {UsersPaginationResultDtoMeta}
     * @memberof AmenitiesPaginationResultDto
     */
    'meta': UsersPaginationResultDtoMeta;
}
/**
 * 
 * @export
 * @interface Amenity
 */
export interface Amenity {
    /**
     * 
     * @type {string}
     * @memberof Amenity
     */
    'id': string;
    /**
     * Soft delete flag
     * @type {boolean}
     * @memberof Amenity
     */
    'isDeleted': boolean;
    /**
     * Soft delete timestamp
     * @type {string}
     * @memberof Amenity
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof Amenity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Amenity
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Amenity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Amenity
     */
    'slug': string;
    /**
     * Icon image for the amenity
     * @type {Image}
     * @memberof Amenity
     */
    'icon': Image | null;
    /**
     * 
     * @type {string}
     * @memberof Amenity
     */
    'type': AmenityTypeEnum;
}

export const AmenityTypeEnum = {
    Room: 'ROOM',
    Property: 'PROPERTY',
    Service: 'SERVICE'
} as const;

export type AmenityTypeEnum = typeof AmenityTypeEnum[keyof typeof AmenityTypeEnum];

/**
 * 
 * @export
 * @interface BlockActivity
 */
export interface BlockActivity {
    /**
     * 
     * @type {string}
     * @memberof BlockActivity
     */
    'id': string;
    /**
     * Soft delete flag
     * @type {boolean}
     * @memberof BlockActivity
     */
    'isDeleted': boolean;
    /**
     * Soft delete timestamp
     * @type {string}
     * @memberof BlockActivity
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof BlockActivity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BlockActivity
     */
    'updatedAt': string;
    /**
     * ID of user who was blocked/unblocked
     * @type {string}
     * @memberof BlockActivity
     */
    'userId': string;
    /**
     * Details of user who was blocked/unblocked
     * @type {User}
     * @memberof BlockActivity
     */
    'user': User;
    /**
     * ID of user who performed the block/unblock action
     * @type {string}
     * @memberof BlockActivity
     */
    'blockedBy': string;
    /**
     * Details of user who performed the block/unblock action
     * @type {User}
     * @memberof BlockActivity
     */
    'blockedByUser': User;
    /**
     * Type of action performed (BLOCK/UNBLOCK)
     * @type {string}
     * @memberof BlockActivity
     */
    'action': BlockActivityActionEnum;
    /**
     * Reason for the block/unblock action
     * @type {string}
     * @memberof BlockActivity
     */
    'reason': string;
}

export const BlockActivityActionEnum = {
    Block: 'BLOCK',
    Unblock: 'UNBLOCK'
} as const;

export type BlockActivityActionEnum = typeof BlockActivityActionEnum[keyof typeof BlockActivityActionEnum];

/**
 * 
 * @export
 * @interface BlockOrUnblockUserDto
 */
export interface BlockOrUnblockUserDto {
    /**
     * The reason for blocking/unblocking the user
     * @type {string}
     * @memberof BlockOrUnblockUserDto
     */
    'reason': string;
    /**
     * The action to perform (BLOCK or UNBLOCK)
     * @type {string}
     * @memberof BlockOrUnblockUserDto
     */
    'action': BlockOrUnblockUserDtoActionEnum;
}

export const BlockOrUnblockUserDtoActionEnum = {
    Block: 'BLOCK',
    Unblock: 'UNBLOCK'
} as const;

export type BlockOrUnblockUserDtoActionEnum = typeof BlockOrUnblockUserDtoActionEnum[keyof typeof BlockOrUnblockUserDtoActionEnum];

/**
 * 
 * @export
 * @interface Booking
 */
export interface Booking {
    /**
     * 
     * @type {string}
     * @memberof Booking
     */
    'id': string;
    /**
     * Soft delete flag
     * @type {boolean}
     * @memberof Booking
     */
    'isDeleted': boolean;
    /**
     * Soft delete timestamp
     * @type {string}
     * @memberof Booking
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof Booking
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Booking
     */
    'updatedAt': string;
    /**
     * Booking code
     * @type {string}
     * @memberof Booking
     */
    'code': string;
    /**
     * Type of booking
     * @type {string}
     * @memberof Booking
     */
    'type': BookingTypeEnum;
    /**
     * Type of booking
     * @type {string}
     * @memberof Booking
     */
    'create_type': BookingCreateTypeEnum;
    /**
     * ID of the room being booked
     * @type {string}
     * @memberof Booking
     */
    'roomId': string;
    /**
     * Room being booked
     * @type {HotelRoom}
     * @memberof Booking
     */
    'room': HotelRoom;
    /**
     * ID of the user making the booking
     * @type {string}
     * @memberof Booking
     */
    'userId': string;
    /**
     * User making the booking
     * @type {User}
     * @memberof Booking
     */
    'user': User;
    /**
     * Booking start date
     * @type {string}
     * @memberof Booking
     */
    'start_date': string;
    /**
     * Booking end date
     * @type {string}
     * @memberof Booking
     */
    'end_date': string;
    /**
     * Booking start time
     * @type {string}
     * @memberof Booking
     */
    'start_time': string;
    /**
     * Booking end time
     * @type {string}
     * @memberof Booking
     */
    'end_time': string;
    /**
     * Number of adults
     * @type {string}
     * @memberof Booking
     */
    'total_amount': string;
    /**
     * Booking status
     * @type {string}
     * @memberof Booking
     */
    'status': BookingStatusEnum;
    /**
     * Reason for canceling the booking
     * @type {string}
     * @memberof Booking
     */
    'cancel_reason': string;
    /**
     * Payment method
     * @type {string}
     * @memberof Booking
     */
    'payment_method': BookingPaymentMethodEnum;
    /**
     * Number of guests
     * @type {number}
     * @memberof Booking
     */
    'number_of_guests': number;
    /**
     * Number of adults
     * @type {number}
     * @memberof Booking
     */
    'adults': number;
    /**
     * Number of children
     * @type {number}
     * @memberof Booking
     */
    'children': number;
    /**
     * Number of infants
     * @type {number}
     * @memberof Booking
     */
    'infants': number;
    /**
     * Special requirements
     * @type {string}
     * @memberof Booking
     */
    'special_requests': string;
    /**
     * Check in time
     * @type {string}
     * @memberof Booking
     */
    'check_in_time': string;
    /**
     * Check out time
     * @type {string}
     * @memberof Booking
     */
    'check_out_time': string;
    /**
     * Payment status
     * @type {string}
     * @memberof Booking
     */
    'payment_status': BookingPaymentStatusEnum;
    /**
     * Payment details
     * @type {object}
     * @memberof Booking
     */
    'payment_details': object;
    /**
     * Guest details
     * @type {GuestDetail}
     * @memberof Booking
     */
    'guest_details': GuestDetail;
    /**
     * Promotion code
     * @type {string}
     * @memberof Booking
     */
    'promotion_code': string;
    /**
     * Is business trip
     * @type {boolean}
     * @memberof Booking
     */
    'is_business_trip': boolean;
}

export const BookingTypeEnum = {
    Hourly: 'HOURLY',
    Nightly: 'NIGHTLY',
    Daily: 'DAILY'
} as const;

export type BookingTypeEnum = typeof BookingTypeEnum[keyof typeof BookingTypeEnum];
export const BookingCreateTypeEnum = {
    OnlineBooking: 'ONLINE_BOOKING',
    AtHotel: 'AT_HOTEL'
} as const;

export type BookingCreateTypeEnum = typeof BookingCreateTypeEnum[keyof typeof BookingCreateTypeEnum];
export const BookingStatusEnum = {
    Pending: 'PENDING',
    WaitingForCheckIn: 'WAITING_FOR_CHECK_IN',
    CheckedIn: 'CHECKED_IN',
    Cancelled: 'CANCELLED',
    Completed: 'COMPLETED',
    Refunded: 'REFUNDED',
    Rejected: 'REJECTED'
} as const;

export type BookingStatusEnum = typeof BookingStatusEnum[keyof typeof BookingStatusEnum];
export const BookingPaymentMethodEnum = {
    Cash: 'CASH',
    Banking: 'BANKING',
    Zalopay: 'ZALOPAY',
    Momo: 'MOMO',
    VnPay: 'VN_PAY',
    VietQr: 'VIET_QR'
} as const;

export type BookingPaymentMethodEnum = typeof BookingPaymentMethodEnum[keyof typeof BookingPaymentMethodEnum];
export const BookingPaymentStatusEnum = {
    Unpaid: 'UNPAID',
    Paid: 'PAID',
    Failed: 'FAILED',
    Refunded: 'REFUNDED'
} as const;

export type BookingPaymentStatusEnum = typeof BookingPaymentStatusEnum[keyof typeof BookingPaymentStatusEnum];

/**
 * 
 * @export
 * @interface BookingsPaginationResultDto
 */
export interface BookingsPaginationResultDto {
    /**
     * 
     * @type {Array<Booking>}
     * @memberof BookingsPaginationResultDto
     */
    'data': Array<Booking>;
    /**
     * 
     * @type {UsersPaginationResultDtoMeta}
     * @memberof BookingsPaginationResultDto
     */
    'meta': UsersPaginationResultDtoMeta;
}
/**
 * 
 * @export
 * @interface Branch
 */
export interface Branch {
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'id': string;
    /**
     * Soft delete flag
     * @type {boolean}
     * @memberof Branch
     */
    'isDeleted': boolean;
    /**
     * Soft delete timestamp
     * @type {string}
     * @memberof Branch
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'updatedAt': string;
    /**
     * ID of the province where this branch is located
     * @type {string}
     * @memberof Branch
     */
    'provinceId': string;
    /**
     * Province where this branch is located
     * @type {Province}
     * @memberof Branch
     */
    'province'?: Province;
    /**
     * Branch\'s thumbnail image
     * @type {Image}
     * @memberof Branch
     */
    'thumbnail': Image;
    /**
     * Branch\'s image gallery
     * @type {Array<Image>}
     * @memberof Branch
     */
    'images': Array<Image>;
    /**
     * Branch\'s name
     * @type {string}
     * @memberof Branch
     */
    'name': string;
    /**
     * Branch\'s slug
     * @type {string}
     * @memberof Branch
     */
    'slug': string;
    /**
     * Branch\'s description
     * @type {string}
     * @memberof Branch
     */
    'description': string;
    /**
     * Branch\'s contact phone number
     * @type {string}
     * @memberof Branch
     */
    'phone': string;
    /**
     * Branch\'s active status
     * @type {boolean}
     * @memberof Branch
     */
    'is_active': boolean;
    /**
     * Branch\'s physical address
     * @type {string}
     * @memberof Branch
     */
    'address': string;
    /**
     * Branch\'s rating
     * @type {number}
     * @memberof Branch
     */
    'rating': number;
}
/**
 * 
 * @export
 * @interface BranchDetail
 */
export interface BranchDetail {
    /**
     * 
     * @type {string}
     * @memberof BranchDetail
     */
    'id': string;
    /**
     * Soft delete flag
     * @type {boolean}
     * @memberof BranchDetail
     */
    'isDeleted': boolean;
    /**
     * Soft delete timestamp
     * @type {string}
     * @memberof BranchDetail
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof BranchDetail
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BranchDetail
     */
    'updatedAt': string;
    /**
     * ID of the province where this branch is located
     * @type {string}
     * @memberof BranchDetail
     */
    'provinceId': string;
    /**
     * Province where this branch is located
     * @type {Province}
     * @memberof BranchDetail
     */
    'province'?: Province;
    /**
     * Branch\'s thumbnail image
     * @type {Image}
     * @memberof BranchDetail
     */
    'thumbnail': Image;
    /**
     * Branch\'s image gallery
     * @type {Array<Image>}
     * @memberof BranchDetail
     */
    'images': Array<Image>;
    /**
     * Branch\'s name
     * @type {string}
     * @memberof BranchDetail
     */
    'name': string;
    /**
     * Branch\'s slug
     * @type {string}
     * @memberof BranchDetail
     */
    'slug': string;
    /**
     * Branch\'s description
     * @type {string}
     * @memberof BranchDetail
     */
    'description': string;
    /**
     * Branch\'s contact phone number
     * @type {string}
     * @memberof BranchDetail
     */
    'phone': string;
    /**
     * Branch\'s active status
     * @type {boolean}
     * @memberof BranchDetail
     */
    'is_active': boolean;
    /**
     * Branch\'s physical address
     * @type {string}
     * @memberof BranchDetail
     */
    'address': string;
    /**
     * Branch\'s rating
     * @type {number}
     * @memberof BranchDetail
     */
    'rating': number;
    /**
     * Amenities available in the branch
     * @type {Array<Amenity>}
     * @memberof BranchDetail
     */
    'amenities': Array<Amenity>;
    /**
     * List of rooms available in the branch
     * @type {Array<RoomDetail>}
     * @memberof BranchDetail
     */
    'rooms': Array<RoomDetail>;
    /**
     * Nearby locations
     * @type {Array<NearBy>}
     * @memberof BranchDetail
     */
    'nearBy': Array<NearBy>;
}
/**
 * 
 * @export
 * @interface BranchesInfinitePaginationResultDto
 */
export interface BranchesInfinitePaginationResultDto {
    /**
     * 
     * @type {Array<Branch>}
     * @memberof BranchesInfinitePaginationResultDto
     */
    'data': Array<Branch>;
    /**
     * 
     * @type {boolean}
     * @memberof BranchesInfinitePaginationResultDto
     */
    'hasNextPage': boolean;
}
/**
 * 
 * @export
 * @interface BranchesPaginationResultDto
 */
export interface BranchesPaginationResultDto {
    /**
     * 
     * @type {Array<Branch>}
     * @memberof BranchesPaginationResultDto
     */
    'data': Array<Branch>;
    /**
     * 
     * @type {UsersPaginationResultDtoMeta}
     * @memberof BranchesPaginationResultDto
     */
    'meta': UsersPaginationResultDtoMeta;
}
/**
 * 
 * @export
 * @interface ChangePasswordDto
 */
export interface ChangePasswordDto {
    /**
     * The current password of the user
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'currentPassword': string;
    /**
     * The new password of the user
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'newPassword': string;
    /**
     * The confirm password of the user
     * @type {string}
     * @memberof ChangePasswordDto
     */
    'confirmPassword': string;
}
/**
 * 
 * @export
 * @interface CreateAmenityDto
 */
export interface CreateAmenityDto {
    /**
     * The name of the amenity
     * @type {string}
     * @memberof CreateAmenityDto
     */
    'name': string;
    /**
     * URL-friendly version of the name (lowercase, hyphenated)
     * @type {string}
     * @memberof CreateAmenityDto
     */
    'slug': string;
    /**
     * Type of amenity (ROOM, PROPERTY, or SERVICE)
     * @type {string}
     * @memberof CreateAmenityDto
     */
    'type': CreateAmenityDtoTypeEnum;
    /**
     * Icon image details
     * @type {Image}
     * @memberof CreateAmenityDto
     */
    'icon': Image;
}

export const CreateAmenityDtoTypeEnum = {
    Room: 'ROOM',
    Property: 'PROPERTY',
    Service: 'SERVICE'
} as const;

export type CreateAmenityDtoTypeEnum = typeof CreateAmenityDtoTypeEnum[keyof typeof CreateAmenityDtoTypeEnum];

/**
 * 
 * @export
 * @interface CreateBookingAtHotelDto
 */
export interface CreateBookingAtHotelDto {
    /**
     * Booking type
     * @type {string}
     * @memberof CreateBookingAtHotelDto
     */
    'type': CreateBookingAtHotelDtoTypeEnum;
    /**
     * Start date of the booking
     * @type {string}
     * @memberof CreateBookingAtHotelDto
     */
    'start_date': string;
    /**
     * End date of the booking
     * @type {string}
     * @memberof CreateBookingAtHotelDto
     */
    'end_date': string;
    /**
     * Start time of the booking
     * @type {string}
     * @memberof CreateBookingAtHotelDto
     */
    'start_time': string;
    /**
     * End time of the booking
     * @type {string}
     * @memberof CreateBookingAtHotelDto
     */
    'end_time': string;
    /**
     * Number of guests
     * @type {number}
     * @memberof CreateBookingAtHotelDto
     */
    'number_of_guests': number;
    /**
     * Number of adults
     * @type {number}
     * @memberof CreateBookingAtHotelDto
     */
    'adults': number;
    /**
     * Number of children
     * @type {number}
     * @memberof CreateBookingAtHotelDto
     */
    'children': number;
    /**
     * Number of infants
     * @type {number}
     * @memberof CreateBookingAtHotelDto
     */
    'infants': number;
    /**
     * Special requirements
     * @type {string}
     * @memberof CreateBookingAtHotelDto
     */
    'special_requests'?: string;
    /**
     * Guest details
     * @type {GuestDetail}
     * @memberof CreateBookingAtHotelDto
     */
    'guest_details'?: GuestDetail;
    /**
     * ID of the room being booked
     * @type {string}
     * @memberof CreateBookingAtHotelDto
     */
    'roomId': string;
    /**
     * Check in time
     * @type {string}
     * @memberof CreateBookingAtHotelDto
     */
    'check_in_time': string;
}

export const CreateBookingAtHotelDtoTypeEnum = {
    Hourly: 'HOURLY',
    Nightly: 'NIGHTLY',
    Daily: 'DAILY'
} as const;

export type CreateBookingAtHotelDtoTypeEnum = typeof CreateBookingAtHotelDtoTypeEnum[keyof typeof CreateBookingAtHotelDtoTypeEnum];

/**
 * 
 * @export
 * @interface CreateBookingOnlineDto
 */
export interface CreateBookingOnlineDto {
    /**
     * Booking type
     * @type {string}
     * @memberof CreateBookingOnlineDto
     */
    'type': CreateBookingOnlineDtoTypeEnum;
    /**
     * Start date of the booking
     * @type {string}
     * @memberof CreateBookingOnlineDto
     */
    'start_date': string;
    /**
     * End date of the booking
     * @type {string}
     * @memberof CreateBookingOnlineDto
     */
    'end_date': string;
    /**
     * Start time of the booking
     * @type {string}
     * @memberof CreateBookingOnlineDto
     */
    'start_time': string;
    /**
     * End time of the booking
     * @type {string}
     * @memberof CreateBookingOnlineDto
     */
    'end_time': string;
    /**
     * Number of guests
     * @type {number}
     * @memberof CreateBookingOnlineDto
     */
    'number_of_guests': number;
    /**
     * Number of adults
     * @type {number}
     * @memberof CreateBookingOnlineDto
     */
    'adults': number;
    /**
     * Number of children
     * @type {number}
     * @memberof CreateBookingOnlineDto
     */
    'children': number;
    /**
     * Number of infants
     * @type {number}
     * @memberof CreateBookingOnlineDto
     */
    'infants': number;
    /**
     * Special requirements
     * @type {string}
     * @memberof CreateBookingOnlineDto
     */
    'special_requests'?: string;
    /**
     * Guest details
     * @type {GuestDetail}
     * @memberof CreateBookingOnlineDto
     */
    'guest_details'?: GuestDetail;
    /**
     * ID of the room detail being booked
     * @type {string}
     * @memberof CreateBookingOnlineDto
     */
    'detailId': string;
    /**
     * Promotion code
     * @type {string}
     * @memberof CreateBookingOnlineDto
     */
    'promotion_code'?: string;
    /**
     * Payment method
     * @type {string}
     * @memberof CreateBookingOnlineDto
     */
    'payment_method'?: CreateBookingOnlineDtoPaymentMethodEnum;
    /**
     * Is this booking a business trip?
     * @type {boolean}
     * @memberof CreateBookingOnlineDto
     */
    'is_business_trip'?: boolean;
}

export const CreateBookingOnlineDtoTypeEnum = {
    Hourly: 'HOURLY',
    Nightly: 'NIGHTLY',
    Daily: 'DAILY'
} as const;

export type CreateBookingOnlineDtoTypeEnum = typeof CreateBookingOnlineDtoTypeEnum[keyof typeof CreateBookingOnlineDtoTypeEnum];
export const CreateBookingOnlineDtoPaymentMethodEnum = {
    Cash: 'CASH',
    Banking: 'BANKING',
    Zalopay: 'ZALOPAY',
    Momo: 'MOMO',
    VnPay: 'VN_PAY',
    VietQr: 'VIET_QR'
} as const;

export type CreateBookingOnlineDtoPaymentMethodEnum = typeof CreateBookingOnlineDtoPaymentMethodEnum[keyof typeof CreateBookingOnlineDtoPaymentMethodEnum];

/**
 * 
 * @export
 * @interface CreateBranchDto
 */
export interface CreateBranchDto {
    /**
     * ID of the province where this branch is located
     * @type {string}
     * @memberof CreateBranchDto
     */
    'provinceId': string;
    /**
     * The branch\'s thumbnail image.
     * @type {Image}
     * @memberof CreateBranchDto
     */
    'thumbnail': Image;
    /**
     * The branch\'s images.
     * @type {Array<Image>}
     * @memberof CreateBranchDto
     */
    'images': Array<Image>;
    /**
     * The branch\'s name.
     * @type {string}
     * @memberof CreateBranchDto
     */
    'name': string;
    /**
     * The branch\'s slug.
     * @type {string}
     * @memberof CreateBranchDto
     */
    'slug': string;
    /**
     * The branch\'s description.
     * @type {string}
     * @memberof CreateBranchDto
     */
    'description': string;
    /**
     * The branch\'s phone number.
     * @type {string}
     * @memberof CreateBranchDto
     */
    'phone': string;
    /**
     * The branch\'s active status.
     * @type {boolean}
     * @memberof CreateBranchDto
     */
    'is_active': boolean;
    /**
     * The branch\'s address.
     * @type {string}
     * @memberof CreateBranchDto
     */
    'address': string;
    /**
     * The branch\'s rating.
     * @type {number}
     * @memberof CreateBranchDto
     */
    'rating': number;
}
/**
 * 
 * @export
 * @interface CreateHotelRoomDto
 */
export interface CreateHotelRoomDto {
    /**
     * Hotel Room\'s name
     * @type {string}
     * @memberof CreateHotelRoomDto
     */
    'name': string;
    /**
     * Hotel Room\'s slug
     * @type {string}
     * @memberof CreateHotelRoomDto
     */
    'slug': string;
    /**
     * Hotel Room\'s status
     * @type {string}
     * @memberof CreateHotelRoomDto
     */
    'status': CreateHotelRoomDtoStatusEnum;
    /**
     * ID of the room detail
     * @type {string}
     * @memberof CreateHotelRoomDto
     */
    'detailId': string;
}

export const CreateHotelRoomDtoStatusEnum = {
    Available: 'AVAILABLE',
    Booked: 'BOOKED',
    Occupied: 'OCCUPIED',
    Maintenance: 'MAINTENANCE'
} as const;

export type CreateHotelRoomDtoStatusEnum = typeof CreateHotelRoomDtoStatusEnum[keyof typeof CreateHotelRoomDtoStatusEnum];

/**
 * 
 * @export
 * @interface CreateProvinceDto
 */
export interface CreateProvinceDto {
    /**
     * Name of the province
     * @type {string}
     * @memberof CreateProvinceDto
     */
    'name': string;
    /**
     * ZIP/Postal code of the province
     * @type {string}
     * @memberof CreateProvinceDto
     */
    'zip_code': string;
    /**
     * URL-friendly slug of the province name
     * @type {string}
     * @memberof CreateProvinceDto
     */
    'slug': string;
}
/**
 * 
 * @export
 * @interface CreateRoomDetailDto
 */
export interface CreateRoomDetailDto {
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDetailDto
     */
    'name': string;
    /**
     * Hotel Room\'s slug
     * @type {string}
     * @memberof CreateRoomDetailDto
     */
    'slug': string;
    /**
     * ID of the branch where this room is located
     * @type {string}
     * @memberof CreateRoomDetailDto
     */
    'branchId': string;
    /**
     * Hotel Room\'s thumbnail image
     * @type {Image}
     * @memberof CreateRoomDetailDto
     */
    'thumbnail': Image;
    /**
     * Hotel Room\'s image gallery
     * @type {Array<Image>}
     * @memberof CreateRoomDetailDto
     */
    'images': Array<Image>;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDetailDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDetailDto
     */
    'room_type': CreateRoomDetailDtoRoomTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomDetailDto
     */
    'bed_type': CreateRoomDetailDtoBedTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateRoomDetailDto
     */
    'amenityIds': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CreateRoomDetailDto
     */
    'max_adults': number;
    /**
     * 
     * @type {number}
     * @memberof CreateRoomDetailDto
     */
    'max_children': number;
    /**
     * Room area(m2)
     * @type {number}
     * @memberof CreateRoomDetailDto
     */
    'area': number;
    /**
     * Hotel Room\'s base price per hour
     * @type {string}
     * @memberof CreateRoomDetailDto
     */
    'base_price_per_hour': string;
    /**
     * Hotel Room\'s base price per night
     * @type {string}
     * @memberof CreateRoomDetailDto
     */
    'base_price_per_night': string;
    /**
     * Hotel Room\'s base price per day
     * @type {string}
     * @memberof CreateRoomDetailDto
     */
    'base_price_per_day': string;
}

export const CreateRoomDetailDtoRoomTypeEnum = {
    Standard: 'STANDARD',
    Superior: 'SUPERIOR',
    Deluxe: 'DELUXE'
} as const;

export type CreateRoomDetailDtoRoomTypeEnum = typeof CreateRoomDetailDtoRoomTypeEnum[keyof typeof CreateRoomDetailDtoRoomTypeEnum];
export const CreateRoomDetailDtoBedTypeEnum = {
    Single: 'SINGLE',
    Double: 'DOUBLE',
    Queen: 'QUEEN',
    King: 'KING'
} as const;

export type CreateRoomDetailDtoBedTypeEnum = typeof CreateRoomDetailDtoBedTypeEnum[keyof typeof CreateRoomDetailDtoBedTypeEnum];

/**
 * 
 * @export
 * @interface CreateRoomPriceHistoryDto
 */
export interface CreateRoomPriceHistoryDto {
    /**
     * Day that the price is applied
     * @type {string}
     * @memberof CreateRoomPriceHistoryDto
     */
    'name': string;
    /**
     * Description of the price history
     * @type {string}
     * @memberof CreateRoomPriceHistoryDto
     */
    'description'?: string;
    /**
     * ID of the room detail
     * @type {string}
     * @memberof CreateRoomPriceHistoryDto
     */
    'roomDetailId': string;
    /**
     * Hotel Room\'s base price per hour
     * @type {string}
     * @memberof CreateRoomPriceHistoryDto
     */
    'price_per_hour'?: string;
    /**
     * Hotel Room\'s base price per day
     * @type {string}
     * @memberof CreateRoomPriceHistoryDto
     */
    'price_per_day'?: string;
    /**
     * Hotel Room\'s base price per night
     * @type {string}
     * @memberof CreateRoomPriceHistoryDto
     */
    'price_per_night'?: string;
    /**
     * Effective from date
     * @type {string}
     * @memberof CreateRoomPriceHistoryDto
     */
    'effective_from': string;
    /**
     * Effective to date
     * @type {string}
     * @memberof CreateRoomPriceHistoryDto
     */
    'effective_to'?: string;
}
/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * The user\'s email address.
     * @type {string}
     * @memberof CreateUserDto
     */
    'email'?: string;
    /**
     * The user\'s phone number.
     * @type {string}
     * @memberof CreateUserDto
     */
    'phone'?: string;
    /**
     * The user\'s password.
     * @type {string}
     * @memberof CreateUserDto
     */
    'password': string;
    /**
     * The user\'s name.
     * @type {string}
     * @memberof CreateUserDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface DeleteUserDto
 */
export interface DeleteUserDto {
    /**
     * Reason for deleting the user
     * @type {string}
     * @memberof DeleteUserDto
     */
    'reason': string;
}
/**
 * 
 * @export
 * @interface DetailTranslationContent
 */
export interface DetailTranslationContent {
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationContent
     */
    'content': string;
    /**
     * 
     * @type {number}
     * @memberof DetailTranslationContent
     */
    'fuzzy': number;
    /**
     * 
     * @type {number}
     * @memberof DetailTranslationContent
     */
    'proofread': number;
    /**
     * 
     * @type {string}
     * @memberof DetailTranslationContent
     */
    'updated': string;
}
/**
 * 
 * @export
 * @interface FilterAmenityDto
 */
export interface FilterAmenityDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof FilterAmenityDto
     */
    'types'?: Array<FilterAmenityDtoTypesEnum>;
    /**
     * 
     * @type {string}
     * @memberof FilterAmenityDto
     */
    'search'?: string;
}

export const FilterAmenityDtoTypesEnum = {
    Room: 'ROOM',
    Property: 'PROPERTY',
    Service: 'SERVICE'
} as const;

export type FilterAmenityDtoTypesEnum = typeof FilterAmenityDtoTypesEnum[keyof typeof FilterAmenityDtoTypesEnum];

/**
 * 
 * @export
 * @interface FilterBookingsDto
 */
export interface FilterBookingsDto {
    /**
     * Filter by booking status
     * @type {Array<string>}
     * @memberof FilterBookingsDto
     */
    'status'?: Array<FilterBookingsDtoStatusEnum>;
    /**
     * Filter by booking type
     * @type {string}
     * @memberof FilterBookingsDto
     */
    'type'?: FilterBookingsDtoTypeEnum;
    /**
     * Search by keyword
     * @type {string}
     * @memberof FilterBookingsDto
     */
    'keyword'?: string;
    /**
     * Filter by branch
     * @type {string}
     * @memberof FilterBookingsDto
     */
    'branchId'?: string;
    /**
     * Filter by user
     * @type {string}
     * @memberof FilterBookingsDto
     */
    'userId'?: string;
    /**
     * Filter by room detail
     * @type {string}
     * @memberof FilterBookingsDto
     */
    'detailId'?: string;
    /**
     * Filter by room
     * @type {string}
     * @memberof FilterBookingsDto
     */
    'roomId'?: string;
    /**
     * Filter by start date
     * @type {string}
     * @memberof FilterBookingsDto
     */
    'start_date'?: string;
    /**
     * Filter by end date
     * @type {string}
     * @memberof FilterBookingsDto
     */
    'end_date'?: string;
    /**
     * Filter by payment status
     * @type {string}
     * @memberof FilterBookingsDto
     */
    'payment_status'?: FilterBookingsDtoPaymentStatusEnum;
    /**
     * Filter by payment method
     * @type {string}
     * @memberof FilterBookingsDto
     */
    'payment_method'?: FilterBookingsDtoPaymentMethodEnum;
}

export const FilterBookingsDtoStatusEnum = {
    Pending: 'PENDING',
    WaitingForCheckIn: 'WAITING_FOR_CHECK_IN',
    CheckedIn: 'CHECKED_IN',
    Cancelled: 'CANCELLED',
    Completed: 'COMPLETED',
    Refunded: 'REFUNDED',
    Rejected: 'REJECTED'
} as const;

export type FilterBookingsDtoStatusEnum = typeof FilterBookingsDtoStatusEnum[keyof typeof FilterBookingsDtoStatusEnum];
export const FilterBookingsDtoTypeEnum = {
    Hourly: 'HOURLY',
    Nightly: 'NIGHTLY',
    Daily: 'DAILY'
} as const;

export type FilterBookingsDtoTypeEnum = typeof FilterBookingsDtoTypeEnum[keyof typeof FilterBookingsDtoTypeEnum];
export const FilterBookingsDtoPaymentStatusEnum = {
    Unpaid: 'UNPAID',
    Paid: 'PAID',
    Failed: 'FAILED',
    Refunded: 'REFUNDED'
} as const;

export type FilterBookingsDtoPaymentStatusEnum = typeof FilterBookingsDtoPaymentStatusEnum[keyof typeof FilterBookingsDtoPaymentStatusEnum];
export const FilterBookingsDtoPaymentMethodEnum = {
    Cash: 'CASH',
    Banking: 'BANKING',
    Zalopay: 'ZALOPAY',
    Momo: 'MOMO',
    VnPay: 'VN_PAY',
    VietQr: 'VIET_QR'
} as const;

export type FilterBookingsDtoPaymentMethodEnum = typeof FilterBookingsDtoPaymentMethodEnum[keyof typeof FilterBookingsDtoPaymentMethodEnum];

/**
 * 
 * @export
 * @interface FilterBranchesDto
 */
export interface FilterBranchesDto {
    /**
     * Search by keyword
     * @type {string}
     * @memberof FilterBranchesDto
     */
    'keyword'?: string;
    /**
     * Filter by active status
     * @type {boolean}
     * @memberof FilterBranchesDto
     */
    'is_active'?: boolean;
    /**
     * Filter by rating
     * @type {number}
     * @memberof FilterBranchesDto
     */
    'rating'?: number;
    /**
     * Filter by province
     * @type {string}
     * @memberof FilterBranchesDto
     */
    'provinceId'?: string;
    /**
     * Filter by province slug
     * @type {string}
     * @memberof FilterBranchesDto
     */
    'provinceSlug'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FilterBranchesDto
     */
    'amenities'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FilterHotelRoomDto
 */
export interface FilterHotelRoomDto {
    /**
     * Search by keyword
     * @type {string}
     * @memberof FilterHotelRoomDto
     */
    'keyword'?: string;
    /**
     * Filter by hotel room status
     * @type {string}
     * @memberof FilterHotelRoomDto
     */
    'status'?: FilterHotelRoomDtoStatusEnum;
    /**
     * Filter by room detail ID
     * @type {string}
     * @memberof FilterHotelRoomDto
     */
    'detailId'?: string;
    /**
     * Filter by room detail slug
     * @type {string}
     * @memberof FilterHotelRoomDto
     */
    'detailSlug'?: string;
}

export const FilterHotelRoomDtoStatusEnum = {
    Available: 'AVAILABLE',
    Booked: 'BOOKED',
    Occupied: 'OCCUPIED',
    Maintenance: 'MAINTENANCE'
} as const;

export type FilterHotelRoomDtoStatusEnum = typeof FilterHotelRoomDtoStatusEnum[keyof typeof FilterHotelRoomDtoStatusEnum];

/**
 * 
 * @export
 * @interface FilterMyBookingsDto
 */
export interface FilterMyBookingsDto {
    /**
     * Filter by booking status
     * @type {Array<string>}
     * @memberof FilterMyBookingsDto
     */
    'status'?: Array<FilterMyBookingsDtoStatusEnum>;
}

export const FilterMyBookingsDtoStatusEnum = {
    Pending: 'PENDING',
    WaitingForCheckIn: 'WAITING_FOR_CHECK_IN',
    CheckedIn: 'CHECKED_IN',
    Cancelled: 'CANCELLED',
    Completed: 'COMPLETED',
    Refunded: 'REFUNDED',
    Rejected: 'REJECTED'
} as const;

export type FilterMyBookingsDtoStatusEnum = typeof FilterMyBookingsDtoStatusEnum[keyof typeof FilterMyBookingsDtoStatusEnum];

/**
 * 
 * @export
 * @interface FilterProvincesDto
 */
export interface FilterProvincesDto {
    /**
     * Search by keyword
     * @type {string}
     * @memberof FilterProvincesDto
     */
    'keyword'?: string;
}
/**
 * 
 * @export
 * @interface FilterRoomDetailDto
 */
export interface FilterRoomDetailDto {
    /**
     * 
     * @type {string}
     * @memberof FilterRoomDetailDto
     */
    'keyword'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilterRoomDetailDto
     */
    'room_type'?: FilterRoomDetailDtoRoomTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FilterRoomDetailDto
     */
    'bed_type'?: FilterRoomDetailDtoBedTypeEnum;
    /**
     * Filter by rating
     * @type {number}
     * @memberof FilterRoomDetailDto
     */
    'rating_from'?: number;
    /**
     * Filter by rating
     * @type {number}
     * @memberof FilterRoomDetailDto
     */
    'rating_to'?: number;
    /**
     * Filter by branch ID
     * @type {string}
     * @memberof FilterRoomDetailDto
     */
    'branchId'?: string;
    /**
     * Filter by branch slug
     * @type {string}
     * @memberof FilterRoomDetailDto
     */
    'branchSlug'?: string;
    /**
     * Filter by province ID
     * @type {string}
     * @memberof FilterRoomDetailDto
     */
    'provinceId'?: string;
    /**
     * Filter by province slug
     * @type {string}
     * @memberof FilterRoomDetailDto
     */
    'provinceSlug'?: string;
    /**
     * Filter by amenities
     * @type {Array<string>}
     * @memberof FilterRoomDetailDto
     */
    'amenities'?: Array<string>;
    /**
     * Filter by minimum price
     * @type {object}
     * @memberof FilterRoomDetailDto
     */
    'minPrice'?: object;
    /**
     * Filter by maximum price
     * @type {object}
     * @memberof FilterRoomDetailDto
     */
    'maxPrice'?: object;
    /**
     * Filter by start date
     * @type {string}
     * @memberof FilterRoomDetailDto
     */
    'startDate'?: string;
    /**
     * Filter by end date
     * @type {string}
     * @memberof FilterRoomDetailDto
     */
    'endDate'?: string;
    /**
     * Filter by start time
     * @type {string}
     * @memberof FilterRoomDetailDto
     */
    'startTime'?: string;
    /**
     * Filter by end time
     * @type {string}
     * @memberof FilterRoomDetailDto
     */
    'endTime'?: string;
    /**
     * Filter by booking type
     * @type {string}
     * @memberof FilterRoomDetailDto
     */
    'bookingType'?: FilterRoomDetailDtoBookingTypeEnum;
    /**
     * Filter by number of adults
     * @type {number}
     * @memberof FilterRoomDetailDto
     */
    'adults'?: number;
    /**
     * Filter by number of children
     * @type {number}
     * @memberof FilterRoomDetailDto
     */
    'children'?: number;
}

export const FilterRoomDetailDtoRoomTypeEnum = {
    Standard: 'STANDARD',
    Superior: 'SUPERIOR',
    Deluxe: 'DELUXE'
} as const;

export type FilterRoomDetailDtoRoomTypeEnum = typeof FilterRoomDetailDtoRoomTypeEnum[keyof typeof FilterRoomDetailDtoRoomTypeEnum];
export const FilterRoomDetailDtoBedTypeEnum = {
    Single: 'SINGLE',
    Double: 'DOUBLE',
    Queen: 'QUEEN',
    King: 'KING'
} as const;

export type FilterRoomDetailDtoBedTypeEnum = typeof FilterRoomDetailDtoBedTypeEnum[keyof typeof FilterRoomDetailDtoBedTypeEnum];
export const FilterRoomDetailDtoBookingTypeEnum = {
    Hourly: 'HOURLY',
    Nightly: 'NIGHTLY',
    Daily: 'DAILY'
} as const;

export type FilterRoomDetailDtoBookingTypeEnum = typeof FilterRoomDetailDtoBookingTypeEnum[keyof typeof FilterRoomDetailDtoBookingTypeEnum];

/**
 * 
 * @export
 * @interface FilterUserDto
 */
export interface FilterUserDto {
    /**
     * 
     * @type {string}
     * @memberof FilterUserDto
     */
    'keyword'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilterUserDto
     */
    'roles'?: FilterUserDtoRolesEnum;
    /**
     * 
     * @type {boolean}
     * @memberof FilterUserDto
     */
    'is_blocked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FilterUserDto
     */
    'is_active'?: boolean;
    /**
     * Filter by branch ID
     * @type {string}
     * @memberof FilterUserDto
     */
    'branchId'?: string;
}

export const FilterUserDtoRolesEnum = {
    User: 'USER',
    Staff: 'STAFF',
    Admin: 'ADMIN'
} as const;

export type FilterUserDtoRolesEnum = typeof FilterUserDtoRolesEnum[keyof typeof FilterUserDtoRolesEnum];

/**
 * 
 * @export
 * @interface GetTranslationsRequestDto
 */
export interface GetTranslationsRequestDto {
    /**
     * Language code to fetch translations for
     * @type {string}
     * @memberof GetTranslationsRequestDto
     */
    'language'?: string;
}
/**
 * 
 * @export
 * @interface GuestDetail
 */
export interface GuestDetail {
    /**
     * Guest identification number
     * @type {string}
     * @memberof GuestDetail
     */
    'identification_number': string;
    /**
     * Guest identification card type
     * @type {string}
     * @memberof GuestDetail
     */
    'identification_card': GuestDetailIdentificationCardEnum;
    /**
     * Front image of the guest identification card
     * @type {Image}
     * @memberof GuestDetail
     */
    'front_image': Image;
    /**
     * Back image of the guest identification card
     * @type {Image}
     * @memberof GuestDetail
     */
    'back_image': Image;
}

export const GuestDetailIdentificationCardEnum = {
    Cccd: 'CCCD',
    Cmnd: 'CMND',
    Cmt: 'CMT'
} as const;

export type GuestDetailIdentificationCardEnum = typeof GuestDetailIdentificationCardEnum[keyof typeof GuestDetailIdentificationCardEnum];

/**
 * 
 * @export
 * @interface HotelRoom
 */
export interface HotelRoom {
    /**
     * 
     * @type {string}
     * @memberof HotelRoom
     */
    'id': string;
    /**
     * Soft delete flag
     * @type {boolean}
     * @memberof HotelRoom
     */
    'isDeleted': boolean;
    /**
     * Soft delete timestamp
     * @type {string}
     * @memberof HotelRoom
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof HotelRoom
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof HotelRoom
     */
    'updatedAt': string;
    /**
     * Hotel Room\'s name
     * @type {string}
     * @memberof HotelRoom
     */
    'name': string;
    /**
     * Hotel Room\'s slug
     * @type {string}
     * @memberof HotelRoom
     */
    'slug': string;
    /**
     * Hotel Room\'s status
     * @type {string}
     * @memberof HotelRoom
     */
    'status': HotelRoomStatusEnum;
    /**
     * ID of the room detail
     * @type {string}
     * @memberof HotelRoom
     */
    'detailId': string;
    /**
     * Room detail
     * @type {RoomDetail}
     * @memberof HotelRoom
     */
    'detail'?: RoomDetail;
    /**
     * List of bookings
     * @type {Array<Booking>}
     * @memberof HotelRoom
     */
    'bookings'?: Array<Booking>;
    /**
     * 
     * @type {UserCount}
     * @memberof HotelRoom
     */
    '_count'?: UserCount;
}

export const HotelRoomStatusEnum = {
    Available: 'AVAILABLE',
    Booked: 'BOOKED',
    Occupied: 'OCCUPIED',
    Maintenance: 'MAINTENANCE'
} as const;

export type HotelRoomStatusEnum = typeof HotelRoomStatusEnum[keyof typeof HotelRoomStatusEnum];

/**
 * 
 * @export
 * @interface HotelRoomPaginationResultDto
 */
export interface HotelRoomPaginationResultDto {
    /**
     * 
     * @type {Array<HotelRoom>}
     * @memberof HotelRoomPaginationResultDto
     */
    'data': Array<HotelRoom>;
    /**
     * 
     * @type {UsersPaginationResultDtoMeta}
     * @memberof HotelRoomPaginationResultDto
     */
    'meta': UsersPaginationResultDtoMeta;
}
/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * The image\'s URL.
     * @type {string}
     * @memberof Image
     */
    'url': string;
    /**
     * The image\'s public ID in Cloudinary.
     * @type {string}
     * @memberof Image
     */
    'publicId': string;
}
/**
 * 
 * @export
 * @interface ImageUploadResponseDto
 */
export interface ImageUploadResponseDto {
    /**
     * The image\'s URL.
     * @type {string}
     * @memberof ImageUploadResponseDto
     */
    'url': string;
    /**
     * The image\'s public ID in Cloudinary.
     * @type {string}
     * @memberof ImageUploadResponseDto
     */
    'publicId': string;
}
/**
 * 
 * @export
 * @interface ImmediateDeleteRoomsDto
 */
export interface ImmediateDeleteRoomsDto {
    /**
     * List of room ids to delete
     * @type {Array<string>}
     * @memberof ImmediateDeleteRoomsDto
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface InitiateForgotPasswordEmailDto
 */
export interface InitiateForgotPasswordEmailDto {
    /**
     * Email address of the user who forgot their password
     * @type {string}
     * @memberof InitiateForgotPasswordEmailDto
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ListTranslationResponseDto
 */
export interface ListTranslationResponseDto {
    /**
     * 
     * @type {ResponseStatus}
     * @memberof ListTranslationResponseDto
     */
    'response': ResponseStatus;
    /**
     * 
     * @type {ListTranslationResult}
     * @memberof ListTranslationResponseDto
     */
    'result': ListTranslationResult;
}
/**
 * 
 * @export
 * @interface ListTranslationResult
 */
export interface ListTranslationResult {
    /**
     * 
     * @type {Array<Term>}
     * @memberof ListTranslationResult
     */
    'terms': Array<Term>;
}
/**
 * 
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     * The user\'s email address or phone number.
     * @type {string}
     * @memberof LoginDto
     */
    'emailOrPhone': string;
    /**
     * The user\'s password.
     * @type {string}
     * @memberof LoginDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponseDto
 */
export interface LoginResponseDto {
    /**
     * New access token
     * @type {string}
     * @memberof LoginResponseDto
     */
    'accessToken': string;
    /**
     * Timestamp when the access token expires
     * @type {number}
     * @memberof LoginResponseDto
     */
    'accessTokenExpires': number;
    /**
     * New refresh token
     * @type {string}
     * @memberof LoginResponseDto
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface LogoutResponseDto
 */
export interface LogoutResponseDto {
    /**
     * Success message
     * @type {string}
     * @memberof LogoutResponseDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface NearBy
 */
export interface NearBy {
    /**
     * Name of the nearby location
     * @type {string}
     * @memberof NearBy
     */
    'name': string;
    /**
     * Distance from the branch
     * @type {string}
     * @memberof NearBy
     */
    'distance': string;
}
/**
 * 
 * @export
 * @interface Province
 */
export interface Province {
    /**
     * 
     * @type {string}
     * @memberof Province
     */
    'id': string;
    /**
     * Soft delete flag
     * @type {boolean}
     * @memberof Province
     */
    'isDeleted': boolean;
    /**
     * Soft delete timestamp
     * @type {string}
     * @memberof Province
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof Province
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Province
     */
    'updatedAt': string;
    /**
     * Name of the province
     * @type {string}
     * @memberof Province
     */
    'name': string;
    /**
     * ZIP/Postal code of the province
     * @type {string}
     * @memberof Province
     */
    'zip_code': string;
    /**
     * Slug of the province
     * @type {string}
     * @memberof Province
     */
    'slug': string;
    /**
     * 
     * @type {ProvinceCount}
     * @memberof Province
     */
    '_count'?: ProvinceCount;
}
/**
 * Count of branches in the province
 * @export
 * @interface ProvinceCount
 */
export interface ProvinceCount {
    /**
     * 
     * @type {number}
     * @memberof ProvinceCount
     */
    'branches'?: number;
}
/**
 * 
 * @export
 * @interface ProvincePaginationResultDto
 */
export interface ProvincePaginationResultDto {
    /**
     * 
     * @type {Array<Province>}
     * @memberof ProvincePaginationResultDto
     */
    'data': Array<Province>;
    /**
     * 
     * @type {UsersPaginationResultDtoMeta}
     * @memberof ProvincePaginationResultDto
     */
    'meta': UsersPaginationResultDtoMeta;
}
/**
 * 
 * @export
 * @interface QueryAmenityDto
 */
export interface QueryAmenityDto {
    /**
     * 
     * @type {number}
     * @memberof QueryAmenityDto
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryAmenityDto
     */
    'pageSize'?: number;
    /**
     * JSON string of FilterAmenityDto
     * @type {string}
     * @memberof QueryAmenityDto
     */
    'filters'?: string;
    /**
     * JSON string of SortAmenityDto
     * @type {string}
     * @memberof QueryAmenityDto
     */
    'sort'?: string;
}
/**
 * 
 * @export
 * @interface QueryBookingsDto
 */
export interface QueryBookingsDto {
    /**
     * 
     * @type {number}
     * @memberof QueryBookingsDto
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryBookingsDto
     */
    'pageSize'?: number;
    /**
     * JSON string of FilterBookingsDto
     * @type {string}
     * @memberof QueryBookingsDto
     */
    'filters'?: string;
    /**
     * JSON string of SortBookingsDto[]
     * @type {string}
     * @memberof QueryBookingsDto
     */
    'sort'?: string;
}
/**
 * 
 * @export
 * @interface QueryBranchesDto
 */
export interface QueryBranchesDto {
    /**
     * 
     * @type {number}
     * @memberof QueryBranchesDto
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryBranchesDto
     */
    'pageSize'?: number;
    /**
     * JSON string of FilterBranchesDto
     * @type {string}
     * @memberof QueryBranchesDto
     */
    'filters'?: string;
    /**
     * JSON string of SortBranchDto[]
     * @type {string}
     * @memberof QueryBranchesDto
     */
    'sort'?: string;
}
/**
 * 
 * @export
 * @interface QueryHotelRoomDto
 */
export interface QueryHotelRoomDto {
    /**
     * 
     * @type {number}
     * @memberof QueryHotelRoomDto
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryHotelRoomDto
     */
    'pageSize'?: number;
    /**
     * JSON string of FilterHotelRoomDto
     * @type {string}
     * @memberof QueryHotelRoomDto
     */
    'filters'?: string;
    /**
     * JSON string of SortHotelRoomDto[]
     * @type {string}
     * @memberof QueryHotelRoomDto
     */
    'sort'?: string;
}
/**
 * 
 * @export
 * @interface QueryMyBookingsDto
 */
export interface QueryMyBookingsDto {
    /**
     * 
     * @type {number}
     * @memberof QueryMyBookingsDto
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryMyBookingsDto
     */
    'pageSize'?: number;
    /**
     * Filter my bookings
     * @type {FilterMyBookingsDto}
     * @memberof QueryMyBookingsDto
     */
    'filters'?: FilterMyBookingsDto;
}
/**
 * 
 * @export
 * @interface QueryProvincesDto
 */
export interface QueryProvincesDto {
    /**
     * 
     * @type {number}
     * @memberof QueryProvincesDto
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryProvincesDto
     */
    'pageSize'?: number;
    /**
     * JSON string of FilterProvincesDto
     * @type {string}
     * @memberof QueryProvincesDto
     */
    'filters'?: string;
    /**
     * JSON string of SortProvinceDto[]
     * @type {string}
     * @memberof QueryProvincesDto
     */
    'sort'?: string;
}
/**
 * 
 * @export
 * @interface QueryRoomDetailDto
 */
export interface QueryRoomDetailDto {
    /**
     * 
     * @type {number}
     * @memberof QueryRoomDetailDto
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryRoomDetailDto
     */
    'pageSize'?: number;
    /**
     * JSON string of FilterRoomDetailDto
     * @type {string}
     * @memberof QueryRoomDetailDto
     */
    'filters'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryRoomDetailDto
     */
    'sort'?: Array<string>;
}
/**
 * 
 * @export
 * @interface QueryUsersDto
 */
export interface QueryUsersDto {
    /**
     * 
     * @type {number}
     * @memberof QueryUsersDto
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryUsersDto
     */
    'pageSize'?: number;
    /**
     * JSON string of FilterUserDto
     * @type {string}
     * @memberof QueryUsersDto
     */
    'filters'?: string;
    /**
     * JSON string of SortUserDto
     * @type {string}
     * @memberof QueryUsersDto
     */
    'sort'?: string;
}
/**
 * 
 * @export
 * @interface RefreshTokenDto
 */
export interface RefreshTokenDto {
    /**
     * The refresh token to renew access
     * @type {string}
     * @memberof RefreshTokenDto
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface RefreshTokenResponseDto
 */
export interface RefreshTokenResponseDto {
    /**
     * New access token
     * @type {string}
     * @memberof RefreshTokenResponseDto
     */
    'accessToken': string;
    /**
     * Timestamp when the access token expires
     * @type {number}
     * @memberof RefreshTokenResponseDto
     */
    'accessTokenExpires': number;
    /**
     * New refresh token
     * @type {string}
     * @memberof RefreshTokenResponseDto
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface RegisterDto
 */
export interface RegisterDto {
    /**
     * 
     * @type {CreateUserDto}
     * @memberof RegisterDto
     */
    'data': CreateUserDto;
    /**
     * 
     * @type {string}
     * @memberof RegisterDto
     */
    'accountIdentifier': RegisterDtoAccountIdentifierEnum;
}

export const RegisterDtoAccountIdentifierEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE'
} as const;

export type RegisterDtoAccountIdentifierEnum = typeof RegisterDtoAccountIdentifierEnum[keyof typeof RegisterDtoAccountIdentifierEnum];

/**
 * 
 * @export
 * @interface RegisterResponseDto
 */
export interface RegisterResponseDto {
    /**
     * The user\'s email address
     * @type {string}
     * @memberof RegisterResponseDto
     */
    'email'?: string;
    /**
     * The user\'s phone number
     * @type {string}
     * @memberof RegisterResponseDto
     */
    'phone'?: string;
    /**
     * The user\'s ID
     * @type {string}
     * @memberof RegisterResponseDto
     */
    'id': string;
    /**
     * The type of identifier used for registration
     * @type {string}
     * @memberof RegisterResponseDto
     */
    'identifier_type': RegisterResponseDtoIdentifierTypeEnum;
}

export const RegisterResponseDtoIdentifierTypeEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE'
} as const;

export type RegisterResponseDtoIdentifierTypeEnum = typeof RegisterResponseDtoIdentifierTypeEnum[keyof typeof RegisterResponseDtoIdentifierTypeEnum];

/**
 * 
 * @export
 * @interface ResetPasswordWithOTPEmailDto
 */
export interface ResetPasswordWithOTPEmailDto {
    /**
     * Email address of the user
     * @type {string}
     * @memberof ResetPasswordWithOTPEmailDto
     */
    'email': string;
    /**
     * Six digit verification code sent to email
     * @type {string}
     * @memberof ResetPasswordWithOTPEmailDto
     */
    'code': string;
    /**
     * New password to set
     * @type {string}
     * @memberof ResetPasswordWithOTPEmailDto
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface ResponseStatus
 */
export interface ResponseStatus {
    /**
     * 
     * @type {string}
     * @memberof ResponseStatus
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseStatus
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseStatus
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface RevokeSessionResponseDto
 */
export interface RevokeSessionResponseDto {
    /**
     * Success message
     * @type {string}
     * @memberof RevokeSessionResponseDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface RoomDetail
 */
export interface RoomDetail {
    /**
     * 
     * @type {string}
     * @memberof RoomDetail
     */
    'id': string;
    /**
     * Soft delete flag
     * @type {boolean}
     * @memberof RoomDetail
     */
    'isDeleted': boolean;
    /**
     * Soft delete timestamp
     * @type {string}
     * @memberof RoomDetail
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof RoomDetail
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RoomDetail
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof RoomDetail
     */
    'name': string;
    /**
     * Hotel Detail\'s slug
     * @type {string}
     * @memberof RoomDetail
     */
    'slug': string;
    /**
     * ID of the branch where this room is located
     * @type {string}
     * @memberof RoomDetail
     */
    'branchId': string;
    /**
     * Branch where this room is located
     * @type {Branch}
     * @memberof RoomDetail
     */
    'branch': Branch;
    /**
     * Hotel Room\'s thumbnail image
     * @type {Image}
     * @memberof RoomDetail
     */
    'thumbnail': Image;
    /**
     * Hotel Room\'s image gallery
     * @type {Array<Image>}
     * @memberof RoomDetail
     */
    'images': Array<Image>;
    /**
     * 
     * @type {string}
     * @memberof RoomDetail
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof RoomDetail
     */
    'room_type': RoomDetailRoomTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RoomDetail
     */
    'bed_type': RoomDetailBedTypeEnum;
    /**
     * Room area in square meters
     * @type {number}
     * @memberof RoomDetail
     */
    'area': number;
    /**
     * 
     * @type {Array<Amenity>}
     * @memberof RoomDetail
     */
    'amenities': Array<Amenity>;
    /**
     * 
     * @type {number}
     * @memberof RoomDetail
     */
    'max_adults': number;
    /**
     * 
     * @type {number}
     * @memberof RoomDetail
     */
    'max_children': number;
    /**
     * 
     * @type {number}
     * @memberof RoomDetail
     */
    'quantity': number;
    /**
     * Hotel Room\'s base price per hour
     * @type {string}
     * @memberof RoomDetail
     */
    'base_price_per_hour': string;
    /**
     * Hotel Room\'s special price per hour
     * @type {string}
     * @memberof RoomDetail
     */
    'special_price_per_hour'?: string;
    /**
     * Hotel Room\'s base price per night
     * @type {string}
     * @memberof RoomDetail
     */
    'base_price_per_night': string;
    /**
     * Hotel Room\'s special price per night
     * @type {string}
     * @memberof RoomDetail
     */
    'special_price_per_night'?: string;
    /**
     * Hotel Room\'s base price per day
     * @type {string}
     * @memberof RoomDetail
     */
    'base_price_per_day': string;
    /**
     * Hotel Room\'s special price per day
     * @type {string}
     * @memberof RoomDetail
     */
    'special_price_per_day'?: string;
    /**
     * 
     * @type {Array<HotelRoom>}
     * @memberof RoomDetail
     */
    'flat_rooms': Array<HotelRoom>;
    /**
     * Price history of this room
     * @type {Array<RoomPriceHistory>}
     * @memberof RoomDetail
     */
    'roomPriceHistories'?: Array<RoomPriceHistory>;
    /**
     * Whether this room is available for booking
     * @type {boolean}
     * @memberof RoomDetail
     */
    'is_available': boolean;
}

export const RoomDetailRoomTypeEnum = {
    Standard: 'STANDARD',
    Superior: 'SUPERIOR',
    Deluxe: 'DELUXE'
} as const;

export type RoomDetailRoomTypeEnum = typeof RoomDetailRoomTypeEnum[keyof typeof RoomDetailRoomTypeEnum];
export const RoomDetailBedTypeEnum = {
    Single: 'SINGLE',
    Double: 'DOUBLE',
    Queen: 'QUEEN',
    King: 'KING'
} as const;

export type RoomDetailBedTypeEnum = typeof RoomDetailBedTypeEnum[keyof typeof RoomDetailBedTypeEnum];

/**
 * 
 * @export
 * @interface RoomDetailInfinitePaginationResultDto
 */
export interface RoomDetailInfinitePaginationResultDto {
    /**
     * 
     * @type {Array<RoomDetail>}
     * @memberof RoomDetailInfinitePaginationResultDto
     */
    'data': Array<RoomDetail>;
    /**
     * 
     * @type {boolean}
     * @memberof RoomDetailInfinitePaginationResultDto
     */
    'hasNextPage': boolean;
}
/**
 * 
 * @export
 * @interface RoomDetailPaginationResultDto
 */
export interface RoomDetailPaginationResultDto {
    /**
     * 
     * @type {Array<RoomDetail>}
     * @memberof RoomDetailPaginationResultDto
     */
    'data': Array<RoomDetail>;
    /**
     * 
     * @type {UsersPaginationResultDtoMeta}
     * @memberof RoomDetailPaginationResultDto
     */
    'meta': UsersPaginationResultDtoMeta;
}
/**
 * 
 * @export
 * @interface RoomPriceHistory
 */
export interface RoomPriceHistory {
    /**
     * 
     * @type {string}
     * @memberof RoomPriceHistory
     */
    'id': string;
    /**
     * Soft delete flag
     * @type {boolean}
     * @memberof RoomPriceHistory
     */
    'isDeleted': boolean;
    /**
     * Soft delete timestamp
     * @type {string}
     * @memberof RoomPriceHistory
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof RoomPriceHistory
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RoomPriceHistory
     */
    'updatedAt': string;
    /**
     * Name of the price history
     * @type {string}
     * @memberof RoomPriceHistory
     */
    'name': string;
    /**
     * Description of the price history
     * @type {string}
     * @memberof RoomPriceHistory
     */
    'description': string;
    /**
     * ID of the room detail this price history belongs to
     * @type {string}
     * @memberof RoomPriceHistory
     */
    'roomDetailId': string;
    /**
     * The associated room detail
     * @type {RoomDetail}
     * @memberof RoomPriceHistory
     */
    'roomDetail'?: RoomDetail;
    /**
     * Price per hour for the room
     * @type {string}
     * @memberof RoomPriceHistory
     */
    'price_per_hour': string;
    /**
     * Price per night for the room
     * @type {string}
     * @memberof RoomPriceHistory
     */
    'price_per_night': string;
    /**
     * Price per day for the room
     * @type {string}
     * @memberof RoomPriceHistory
     */
    'price_per_day': string;
    /**
     * Start date when this price becomes effective
     * @type {string}
     * @memberof RoomPriceHistory
     */
    'effective_from': string;
    /**
     * End date when this price expires
     * @type {string}
     * @memberof RoomPriceHistory
     */
    'effective_to': string;
    /**
     * Whether this price is currently being applied
     * @type {boolean}
     * @memberof RoomPriceHistory
     */
    'is_applied': boolean;
}
/**
 * 
 * @export
 * @interface SessionResponseDto
 */
export interface SessionResponseDto {
    /**
     * List of active user sessions
     * @type {Array<string>}
     * @memberof SessionResponseDto
     */
    'sessions': Array<string>;
}
/**
 * 
 * @export
 * @interface SortAmenityDto
 */
export interface SortAmenityDto {
    /**
     * Key of Entity to sort
     * @type {string}
     * @memberof SortAmenityDto
     */
    'orderBy': string;
    /**
     * Order of sorting
     * @type {string}
     * @memberof SortAmenityDto
     */
    'order': SortAmenityDtoOrderEnum;
}

export const SortAmenityDtoOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortAmenityDtoOrderEnum = typeof SortAmenityDtoOrderEnum[keyof typeof SortAmenityDtoOrderEnum];

/**
 * 
 * @export
 * @interface SortBookingsDto
 */
export interface SortBookingsDto {
    /**
     * Key of Entity to sort
     * @type {string}
     * @memberof SortBookingsDto
     */
    'orderBy': string;
    /**
     * Order of sorting
     * @type {string}
     * @memberof SortBookingsDto
     */
    'order': SortBookingsDtoOrderEnum;
}

export const SortBookingsDtoOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortBookingsDtoOrderEnum = typeof SortBookingsDtoOrderEnum[keyof typeof SortBookingsDtoOrderEnum];

/**
 * 
 * @export
 * @interface SortBranchDto
 */
export interface SortBranchDto {
    /**
     * Key of Entity to sort
     * @type {string}
     * @memberof SortBranchDto
     */
    'orderBy': string;
    /**
     * Order of sorting
     * @type {string}
     * @memberof SortBranchDto
     */
    'order': SortBranchDtoOrderEnum;
}

export const SortBranchDtoOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortBranchDtoOrderEnum = typeof SortBranchDtoOrderEnum[keyof typeof SortBranchDtoOrderEnum];

/**
 * 
 * @export
 * @interface SortHotelRoomDto
 */
export interface SortHotelRoomDto {
    /**
     * Key of Entity to sort
     * @type {string}
     * @memberof SortHotelRoomDto
     */
    'orderBy': string;
    /**
     * Order of sorting
     * @type {string}
     * @memberof SortHotelRoomDto
     */
    'order': SortHotelRoomDtoOrderEnum;
}

export const SortHotelRoomDtoOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortHotelRoomDtoOrderEnum = typeof SortHotelRoomDtoOrderEnum[keyof typeof SortHotelRoomDtoOrderEnum];

/**
 * 
 * @export
 * @interface SortProvinceDto
 */
export interface SortProvinceDto {
    /**
     * Key of Entity to sort
     * @type {string}
     * @memberof SortProvinceDto
     */
    'orderBy': string;
    /**
     * Order of sorting
     * @type {string}
     * @memberof SortProvinceDto
     */
    'order': SortProvinceDtoOrderEnum;
}

export const SortProvinceDtoOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortProvinceDtoOrderEnum = typeof SortProvinceDtoOrderEnum[keyof typeof SortProvinceDtoOrderEnum];

/**
 * 
 * @export
 * @interface SortRoomDetailDto
 */
export interface SortRoomDetailDto {
    /**
     * Key of Entity to sort
     * @type {string}
     * @memberof SortRoomDetailDto
     */
    'orderBy': string;
    /**
     * Order of sorting
     * @type {string}
     * @memberof SortRoomDetailDto
     */
    'order': SortRoomDetailDtoOrderEnum;
}

export const SortRoomDetailDtoOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortRoomDetailDtoOrderEnum = typeof SortRoomDetailDtoOrderEnum[keyof typeof SortRoomDetailDtoOrderEnum];

/**
 * 
 * @export
 * @interface SortUserDto
 */
export interface SortUserDto {
    /**
     * Key of User
     * @type {string}
     * @memberof SortUserDto
     */
    'orderBy': string;
    /**
     * Order of sorting
     * @type {string}
     * @memberof SortUserDto
     */
    'order': SortUserDtoOrderEnum;
}

export const SortUserDtoOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortUserDtoOrderEnum = typeof SortUserDtoOrderEnum[keyof typeof SortUserDtoOrderEnum];

/**
 * 
 * @export
 * @interface Term
 */
export interface Term {
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'term': string;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'context': string;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'plural'?: string;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'updated'?: string;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'reference'?: string;
    /**
     * 
     * @type {DetailTranslationContent}
     * @memberof Term
     */
    'translation': DetailTranslationContent;
}
/**
 * 
 * @export
 * @interface TranslationContent
 */
export interface TranslationContent {
    /**
     * 
     * @type {string}
     * @memberof TranslationContent
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface TranslationData
 */
export interface TranslationData {
    /**
     * The term to translate
     * @type {string}
     * @memberof TranslationData
     */
    'term': string;
    /**
     * 
     * @type {TranslationContent}
     * @memberof TranslationData
     */
    'translation': TranslationContent;
    /**
     * Optional context for the translation
     * @type {string}
     * @memberof TranslationData
     */
    'context'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAmenityDto
 */
export interface UpdateAmenityDto {
    /**
     * The name of the amenity
     * @type {string}
     * @memberof UpdateAmenityDto
     */
    'name'?: string;
    /**
     * URL-friendly version of the name (lowercase, hyphenated)
     * @type {string}
     * @memberof UpdateAmenityDto
     */
    'slug'?: string;
    /**
     * Type of amenity (ROOM, PROPERTY, or SERVICE)
     * @type {string}
     * @memberof UpdateAmenityDto
     */
    'type'?: UpdateAmenityDtoTypeEnum;
    /**
     * Icon image details
     * @type {Image}
     * @memberof UpdateAmenityDto
     */
    'icon'?: Image;
}

export const UpdateAmenityDtoTypeEnum = {
    Room: 'ROOM',
    Property: 'PROPERTY',
    Service: 'SERVICE'
} as const;

export type UpdateAmenityDtoTypeEnum = typeof UpdateAmenityDtoTypeEnum[keyof typeof UpdateAmenityDtoTypeEnum];

/**
 * 
 * @export
 * @interface UpdateBranchDto
 */
export interface UpdateBranchDto {
    /**
     * ID of the province where this branch is located
     * @type {string}
     * @memberof UpdateBranchDto
     */
    'provinceId'?: string;
    /**
     * The branch\'s thumbnail image.
     * @type {Image}
     * @memberof UpdateBranchDto
     */
    'thumbnail'?: Image;
    /**
     * The branch\'s images.
     * @type {Array<Image>}
     * @memberof UpdateBranchDto
     */
    'images'?: Array<Image>;
    /**
     * The branch\'s name.
     * @type {string}
     * @memberof UpdateBranchDto
     */
    'name'?: string;
    /**
     * The branch\'s slug.
     * @type {string}
     * @memberof UpdateBranchDto
     */
    'slug'?: string;
    /**
     * The branch\'s description.
     * @type {string}
     * @memberof UpdateBranchDto
     */
    'description'?: string;
    /**
     * The branch\'s phone number.
     * @type {string}
     * @memberof UpdateBranchDto
     */
    'phone'?: string;
    /**
     * The branch\'s active status.
     * @type {boolean}
     * @memberof UpdateBranchDto
     */
    'is_active'?: boolean;
    /**
     * The branch\'s address.
     * @type {string}
     * @memberof UpdateBranchDto
     */
    'address'?: string;
    /**
     * The branch\'s rating.
     * @type {number}
     * @memberof UpdateBranchDto
     */
    'rating'?: number;
    /**
     * Branch amenities
     * @type {Array<string>}
     * @memberof UpdateBranchDto
     */
    'amenityIds'?: Array<string>;
    /**
     * Nearby locations
     * @type {Array<NearBy>}
     * @memberof UpdateBranchDto
     */
    'nearBy'?: Array<NearBy>;
}
/**
 * 
 * @export
 * @interface UpdateHotelRoomDto
 */
export interface UpdateHotelRoomDto {
    /**
     * Hotel Room\'s name
     * @type {string}
     * @memberof UpdateHotelRoomDto
     */
    'name'?: string;
    /**
     * Hotel Room\'s slug
     * @type {string}
     * @memberof UpdateHotelRoomDto
     */
    'slug'?: string;
    /**
     * Hotel Room\'s status
     * @type {string}
     * @memberof UpdateHotelRoomDto
     */
    'status'?: UpdateHotelRoomDtoStatusEnum;
}

export const UpdateHotelRoomDtoStatusEnum = {
    Available: 'AVAILABLE',
    Booked: 'BOOKED',
    Occupied: 'OCCUPIED',
    Maintenance: 'MAINTENANCE'
} as const;

export type UpdateHotelRoomDtoStatusEnum = typeof UpdateHotelRoomDtoStatusEnum[keyof typeof UpdateHotelRoomDtoStatusEnum];

/**
 * 
 * @export
 * @interface UpdateProfileDto
 */
export interface UpdateProfileDto {
    /**
     * Full name of the user
     * @type {string}
     * @memberof UpdateProfileDto
     */
    'name'?: string;
    /**
     * Avatar of the user
     * @type {Image}
     * @memberof UpdateProfileDto
     */
    'avatar'?: Image;
    /**
     * Birth date of the user
     * @type {string}
     * @memberof UpdateProfileDto
     */
    'birth_date'?: string;
    /**
     * User gender
     * @type {string}
     * @memberof UpdateProfileDto
     */
    'gender'?: UpdateProfileDtoGenderEnum;
    /**
     * User email
     * @type {string}
     * @memberof UpdateProfileDto
     */
    'email'?: string;
    /**
     * User phone number
     * @type {string}
     * @memberof UpdateProfileDto
     */
    'phone'?: string;
}

export const UpdateProfileDtoGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE'
} as const;

export type UpdateProfileDtoGenderEnum = typeof UpdateProfileDtoGenderEnum[keyof typeof UpdateProfileDtoGenderEnum];

/**
 * 
 * @export
 * @interface UpdateProvinceDto
 */
export interface UpdateProvinceDto {
    /**
     * Name of the province
     * @type {string}
     * @memberof UpdateProvinceDto
     */
    'name'?: string;
    /**
     * ZIP/Postal code of the province
     * @type {string}
     * @memberof UpdateProvinceDto
     */
    'zip_code'?: string;
    /**
     * URL-friendly slug of the province name
     * @type {string}
     * @memberof UpdateProvinceDto
     */
    'slug'?: string;
}
/**
 * 
 * @export
 * @interface UpdateRoomDetailDto
 */
export interface UpdateRoomDetailDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDetailDto
     */
    'name'?: string;
    /**
     * Hotel Room\'s slug
     * @type {string}
     * @memberof UpdateRoomDetailDto
     */
    'slug'?: string;
    /**
     * ID of the branch where this room is located
     * @type {string}
     * @memberof UpdateRoomDetailDto
     */
    'branchId'?: string;
    /**
     * Hotel Room\'s thumbnail image
     * @type {Image}
     * @memberof UpdateRoomDetailDto
     */
    'thumbnail'?: Image;
    /**
     * Hotel Room\'s image gallery
     * @type {Array<Image>}
     * @memberof UpdateRoomDetailDto
     */
    'images'?: Array<Image>;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDetailDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDetailDto
     */
    'room_type'?: UpdateRoomDetailDtoRoomTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoomDetailDto
     */
    'bed_type'?: UpdateRoomDetailDtoBedTypeEnum;
    /**
     * Branch amenities
     * @type {Array<string>}
     * @memberof UpdateRoomDetailDto
     */
    'amenityIds'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof UpdateRoomDetailDto
     */
    'max_adults'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateRoomDetailDto
     */
    'max_children'?: number;
    /**
     * Room area(m2)
     * @type {number}
     * @memberof UpdateRoomDetailDto
     */
    'area'?: number;
    /**
     * Hotel Room\'s base price per hour
     * @type {string}
     * @memberof UpdateRoomDetailDto
     */
    'base_price_per_hour'?: string;
    /**
     * Hotel Room\'s base price per night
     * @type {string}
     * @memberof UpdateRoomDetailDto
     */
    'base_price_per_night'?: string;
    /**
     * Hotel Room\'s base price per day
     * @type {string}
     * @memberof UpdateRoomDetailDto
     */
    'base_price_per_day'?: string;
    /**
     * Hotel Room\'s special price per hour
     * @type {string}
     * @memberof UpdateRoomDetailDto
     */
    'special_price_per_hour'?: string;
    /**
     * Hotel Room\'s special price per night
     * @type {string}
     * @memberof UpdateRoomDetailDto
     */
    'special_price_per_night'?: string;
    /**
     * Hotel Room\'s special price per day
     * @type {string}
     * @memberof UpdateRoomDetailDto
     */
    'special_price_per_day'?: string;
}

export const UpdateRoomDetailDtoRoomTypeEnum = {
    Standard: 'STANDARD',
    Superior: 'SUPERIOR',
    Deluxe: 'DELUXE'
} as const;

export type UpdateRoomDetailDtoRoomTypeEnum = typeof UpdateRoomDetailDtoRoomTypeEnum[keyof typeof UpdateRoomDetailDtoRoomTypeEnum];
export const UpdateRoomDetailDtoBedTypeEnum = {
    Single: 'SINGLE',
    Double: 'DOUBLE',
    Queen: 'QUEEN',
    King: 'KING'
} as const;

export type UpdateRoomDetailDtoBedTypeEnum = typeof UpdateRoomDetailDtoBedTypeEnum[keyof typeof UpdateRoomDetailDtoBedTypeEnum];

/**
 * 
 * @export
 * @interface UpdateRoomPriceHistoryDto
 */
export interface UpdateRoomPriceHistoryDto {
    /**
     * Day that the price is applied
     * @type {string}
     * @memberof UpdateRoomPriceHistoryDto
     */
    'name'?: string;
    /**
     * Description of the price history
     * @type {string}
     * @memberof UpdateRoomPriceHistoryDto
     */
    'description'?: string;
    /**
     * Hotel Room\'s base price per hour
     * @type {string}
     * @memberof UpdateRoomPriceHistoryDto
     */
    'price_per_hour'?: string;
    /**
     * Hotel Room\'s base price per day
     * @type {string}
     * @memberof UpdateRoomPriceHistoryDto
     */
    'price_per_day'?: string;
    /**
     * Hotel Room\'s base price per night
     * @type {string}
     * @memberof UpdateRoomPriceHistoryDto
     */
    'price_per_night'?: string;
    /**
     * Effective from date
     * @type {string}
     * @memberof UpdateRoomPriceHistoryDto
     */
    'effective_from'?: string;
    /**
     * Effective to date
     * @type {string}
     * @memberof UpdateRoomPriceHistoryDto
     */
    'effective_to'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * Soft delete flag
     * @type {boolean}
     * @memberof User
     */
    'isDeleted': boolean;
    /**
     * Soft delete timestamp
     * @type {string}
     * @memberof User
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phone': string;
    /**
     * The user birth date
     * @type {string}
     * @memberof User
     */
    'birth_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'gender'?: UserGenderEnum;
    /**
     * User avatar
     * @type {Image}
     * @memberof User
     */
    'avatar'?: Image;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'verified_email': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'verified_phone': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'identifier_type': UserIdentifierTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_blocked': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role': UserRoleEnum;
    /**
     * Branch details where user works
     * @type {Branch}
     * @memberof User
     */
    'working_at'?: Branch;
    /**
     * 
     * @type {UserCount}
     * @memberof User
     */
    '_count'?: UserCount;
}

export const UserGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE'
} as const;

export type UserGenderEnum = typeof UserGenderEnum[keyof typeof UserGenderEnum];
export const UserIdentifierTypeEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE'
} as const;

export type UserIdentifierTypeEnum = typeof UserIdentifierTypeEnum[keyof typeof UserIdentifierTypeEnum];
export const UserRoleEnum = {
    User: 'USER',
    Staff: 'STAFF',
    Admin: 'ADMIN'
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];

/**
 * Count of bookings
 * @export
 * @interface UserCount
 */
export interface UserCount {
    /**
     * 
     * @type {number}
     * @memberof UserCount
     */
    'bookings'?: number;
}
/**
 * 
 * @export
 * @interface UserDetail
 */
export interface UserDetail {
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'id': string;
    /**
     * Soft delete flag
     * @type {boolean}
     * @memberof UserDetail
     */
    'isDeleted': boolean;
    /**
     * Soft delete timestamp
     * @type {string}
     * @memberof UserDetail
     */
    'deletedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'phone': string;
    /**
     * The user birth date
     * @type {string}
     * @memberof UserDetail
     */
    'birth_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'gender'?: UserDetailGenderEnum;
    /**
     * User avatar
     * @type {Image}
     * @memberof UserDetail
     */
    'avatar'?: Image;
    /**
     * 
     * @type {boolean}
     * @memberof UserDetail
     */
    'verified_email': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserDetail
     */
    'verified_phone': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'identifier_type': UserDetailIdentifierTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserDetail
     */
    'is_blocked': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'role': UserDetailRoleEnum;
    /**
     * Branch details where user works
     * @type {Branch}
     * @memberof UserDetail
     */
    'working_at'?: Branch;
    /**
     * 
     * @type {UserCount}
     * @memberof UserDetail
     */
    '_count'?: UserCount;
    /**
     * Date when user was blocked
     * @type {string}
     * @memberof UserDetail
     */
    'blocked_at'?: string;
    /**
     * Reason for blocking the user
     * @type {string}
     * @memberof UserDetail
     */
    'blocked_reason'?: string;
    /**
     * Reason for deleting the user
     * @type {string}
     * @memberof UserDetail
     */
    'deleted_reason'?: string;
    /**
     * Stored identity (email/phone) before deletion
     * @type {string}
     * @memberof UserDetail
     */
    'deleted_identity'?: string;
    /**
     * Whether the user is active
     * @type {boolean}
     * @memberof UserDetail
     */
    'is_active': boolean;
    /**
     * ID of the branch where user works (for staff)
     * @type {string}
     * @memberof UserDetail
     */
    'branchId'?: string;
    /**
     * User bookings history
     * @type {Array<Booking>}
     * @memberof UserDetail
     */
    'bookings': Array<Booking>;
    /**
     * User loyalty points
     * @type {number}
     * @memberof UserDetail
     */
    'loyalty_points': number;
    /**
     * History of blocks received by user
     * @type {Array<BlockActivity>}
     * @memberof UserDetail
     */
    'blockHistory': Array<BlockActivity>;
    /**
     * History of blocks given by user
     * @type {Array<BlockActivity>}
     * @memberof UserDetail
     */
    'blockedByMe': Array<BlockActivity>;
}

export const UserDetailGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE'
} as const;

export type UserDetailGenderEnum = typeof UserDetailGenderEnum[keyof typeof UserDetailGenderEnum];
export const UserDetailIdentifierTypeEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE'
} as const;

export type UserDetailIdentifierTypeEnum = typeof UserDetailIdentifierTypeEnum[keyof typeof UserDetailIdentifierTypeEnum];
export const UserDetailRoleEnum = {
    User: 'USER',
    Staff: 'STAFF',
    Admin: 'ADMIN'
} as const;

export type UserDetailRoleEnum = typeof UserDetailRoleEnum[keyof typeof UserDetailRoleEnum];

/**
 * 
 * @export
 * @interface UsersPaginationResultDto
 */
export interface UsersPaginationResultDto {
    /**
     * 
     * @type {Array<User>}
     * @memberof UsersPaginationResultDto
     */
    'data': Array<User>;
    /**
     * 
     * @type {UsersPaginationResultDtoMeta}
     * @memberof UsersPaginationResultDto
     */
    'meta': UsersPaginationResultDtoMeta;
}
/**
 * 
 * @export
 * @interface UsersPaginationResultDtoMeta
 */
export interface UsersPaginationResultDtoMeta {
    /**
     * 
     * @type {number}
     * @memberof UsersPaginationResultDtoMeta
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof UsersPaginationResultDtoMeta
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof UsersPaginationResultDtoMeta
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof UsersPaginationResultDtoMeta
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface VerificationEmailDto
 */
export interface VerificationEmailDto {
    /**
     * Email address to send verification code
     * @type {string}
     * @memberof VerificationEmailDto
     */
    'to': string;
    /**
     * Verification code to be sent
     * @type {string}
     * @memberof VerificationEmailDto
     */
    'code': string;
    /**
     * Language for email template
     * @type {string}
     * @memberof VerificationEmailDto
     */
    'lang'?: VerificationEmailDtoLangEnum;
    /**
     * Type of verification email
     * @type {string}
     * @memberof VerificationEmailDto
     */
    'type': VerificationEmailDtoTypeEnum;
}

export const VerificationEmailDtoLangEnum = {
    En: 'en',
    Vi: 'vi'
} as const;

export type VerificationEmailDtoLangEnum = typeof VerificationEmailDtoLangEnum[keyof typeof VerificationEmailDtoLangEnum];
export const VerificationEmailDtoTypeEnum = {
    VerifyAccount: 'VERIFY_ACCOUNT',
    ForgotPassword: 'FORGOT_PASSWORD'
} as const;

export type VerificationEmailDtoTypeEnum = typeof VerificationEmailDtoTypeEnum[keyof typeof VerificationEmailDtoTypeEnum];

/**
 * 
 * @export
 * @interface VerifyCodeDto
 */
export interface VerifyCodeDto {
    /**
     * User ID
     * @type {string}
     * @memberof VerifyCodeDto
     */
    'userId': string;
    /**
     * Account type
     * @type {string}
     * @memberof VerifyCodeDto
     */
    'type': string;
    /**
     * Verification code
     * @type {string}
     * @memberof VerifyCodeDto
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface VerifyCodeResponseDto
 */
export interface VerifyCodeResponseDto {
    /**
     * Verification status
     * @type {boolean}
     * @memberof VerifyCodeResponseDto
     */
    'success': boolean;
    /**
     * User ID
     * @type {string}
     * @memberof VerifyCodeResponseDto
     */
    'userId': string;
    /**
     * Type of verification
     * @type {string}
     * @memberof VerifyCodeResponseDto
     */
    'type': VerifyCodeResponseDtoTypeEnum;
}

export const VerifyCodeResponseDtoTypeEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE'
} as const;

export type VerifyCodeResponseDtoTypeEnum = typeof VerifyCodeResponseDtoTypeEnum[keyof typeof VerifyCodeResponseDtoTypeEnum];

/**
 * 
 * @export
 * @interface VerifyEmailDto
 */
export interface VerifyEmailDto {
    /**
     * User ID
     * @type {string}
     * @memberof VerifyEmailDto
     */
    'userId': string;
    /**
     * Verification code sent to email
     * @type {string}
     * @memberof VerifyEmailDto
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface VerifyEmailOTP
 */
export interface VerifyEmailOTP {
    /**
     * Email
     * @type {string}
     * @memberof VerifyEmailOTP
     */
    'email': string;
    /**
     * Verification code
     * @type {string}
     * @memberof VerifyEmailOTP
     */
    'code': string;
}

/**
 * AmenitiesApi - axios parameter creator
 * @export
 */
export const AmenitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new amenity
         * @param {CreateAmenityDto} createAmenityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerCreate: async (createAmenityDto: CreateAmenityDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAmenityDto' is not null or undefined
            assertParamExists('amenitiesControllerCreate', 'createAmenityDto', createAmenityDto)
            const localVarPath = `/api/amenities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAmenityDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get amenities
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterAmenityDto
         * @param {string} [sort] JSON string of SortAmenityDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerFindMany: async (page?: number, pageSize?: number, filters?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/amenities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('amenitiesControllerFindOne', 'id', id)
            const localVarPath = `/api/amenities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('amenitiesControllerRemove', 'id', id)
            const localVarPath = `/api/amenities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update amenity
         * @param {string} id 
         * @param {UpdateAmenityDto} updateAmenityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerUpdate: async (id: string, updateAmenityDto: UpdateAmenityDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('amenitiesControllerUpdate', 'id', id)
            // verify required parameter 'updateAmenityDto' is not null or undefined
            assertParamExists('amenitiesControllerUpdate', 'updateAmenityDto', updateAmenityDto)
            const localVarPath = `/api/amenities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAmenityDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AmenitiesApi - functional programming interface
 * @export
 */
export const AmenitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AmenitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new amenity
         * @param {CreateAmenityDto} createAmenityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async amenitiesControllerCreate(createAmenityDto: CreateAmenityDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Amenity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.amenitiesControllerCreate(createAmenityDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AmenitiesApi.amenitiesControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get amenities
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterAmenityDto
         * @param {string} [sort] JSON string of SortAmenityDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async amenitiesControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AmenitiesPaginationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.amenitiesControllerFindMany(page, pageSize, filters, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AmenitiesApi.amenitiesControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async amenitiesControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.amenitiesControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AmenitiesApi.amenitiesControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async amenitiesControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.amenitiesControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AmenitiesApi.amenitiesControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update amenity
         * @param {string} id 
         * @param {UpdateAmenityDto} updateAmenityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async amenitiesControllerUpdate(id: string, updateAmenityDto: UpdateAmenityDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Amenity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.amenitiesControllerUpdate(id, updateAmenityDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AmenitiesApi.amenitiesControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AmenitiesApi - factory interface
 * @export
 */
export const AmenitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AmenitiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new amenity
         * @param {CreateAmenityDto} createAmenityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerCreate(createAmenityDto: CreateAmenityDto, options?: RawAxiosRequestConfig): AxiosPromise<Amenity> {
            return localVarFp.amenitiesControllerCreate(createAmenityDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get amenities
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterAmenityDto
         * @param {string} [sort] JSON string of SortAmenityDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<AmenitiesPaginationResultDto> {
            return localVarFp.amenitiesControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.amenitiesControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.amenitiesControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update amenity
         * @param {string} id 
         * @param {UpdateAmenityDto} updateAmenityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amenitiesControllerUpdate(id: string, updateAmenityDto: UpdateAmenityDto, options?: RawAxiosRequestConfig): AxiosPromise<Amenity> {
            return localVarFp.amenitiesControllerUpdate(id, updateAmenityDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AmenitiesApi - object-oriented interface
 * @export
 * @class AmenitiesApi
 * @extends {BaseAPI}
 */
export class AmenitiesApi extends BaseAPI {
    /**
     * 
     * @summary Create new amenity
     * @param {CreateAmenityDto} createAmenityDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmenitiesApi
     */
    public amenitiesControllerCreate(createAmenityDto: CreateAmenityDto, options?: RawAxiosRequestConfig) {
        return AmenitiesApiFp(this.configuration).amenitiesControllerCreate(createAmenityDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get amenities
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [filters] JSON string of FilterAmenityDto
     * @param {string} [sort] JSON string of SortAmenityDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmenitiesApi
     */
    public amenitiesControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return AmenitiesApiFp(this.configuration).amenitiesControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmenitiesApi
     */
    public amenitiesControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return AmenitiesApiFp(this.configuration).amenitiesControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmenitiesApi
     */
    public amenitiesControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return AmenitiesApiFp(this.configuration).amenitiesControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update amenity
     * @param {string} id 
     * @param {UpdateAmenityDto} updateAmenityDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmenitiesApi
     */
    public amenitiesControllerUpdate(id: string, updateAmenityDto: UpdateAmenityDto, options?: RawAxiosRequestConfig) {
        return AmenitiesApiFp(this.configuration).amenitiesControllerUpdate(id, updateAmenityDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AppApi - axios parameter creator
 * @export
 */
export const AppApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppApi - functional programming interface
 * @export
 */
export const AppApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerGetHello(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetHello(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppApi.appControllerGetHello']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AppApi - factory interface
 * @export
 */
export const AppApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.appControllerGetHello(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppApi - object-oriented interface
 * @export
 * @class AppApi
 * @extends {BaseAPI}
 */
export class AppApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppApi
     */
    public appControllerGetHello(options?: RawAxiosRequestConfig) {
        return AppApiFp(this.configuration).appControllerGetHello(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change user password
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerChangePassword: async (changePasswordDto: ChangePasswordDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordDto' is not null or undefined
            assertParamExists('authControllerChangePassword', 'changePasswordDto', changePasswordDto)
            const localVarPath = `/api/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all active sessions for the current user
         * @summary Get active sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetActiveSessions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get analytics data for user sessions. Requires ADMIN role.
         * @summary Get session analytics
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetSessionAnalytics: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('authControllerGetSessionAnalytics', 'userId', userId)
            const localVarPath = `/api/auth/sessions/analytics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get suspicious activities for a specific user. Requires ADMIN role.
         * @summary Get suspicious activities
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetSuspiciousActivities: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('authControllerGetSuspiciousActivities', 'userId', userId)
            const localVarPath = `/api/auth/users/{userId}/suspicious-activities`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate forgot password process
         * @param {InitiateForgotPasswordEmailDto} initiateForgotPasswordEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerInitiateForgotPassword: async (initiateForgotPasswordEmailDto: InitiateForgotPasswordEmailDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'initiateForgotPasswordEmailDto' is not null or undefined
            assertParamExists('authControllerInitiateForgotPassword', 'initiateForgotPasswordEmailDto', initiateForgotPasswordEmailDto)
            const localVarPath = `/api/auth/forgot-password/email/initiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(initiateForgotPasswordEmailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userAgent 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (userAgent: string, loginDto: LoginDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAgent' is not null or undefined
            assertParamExists('authControllerLogin', 'userAgent', userAgent)
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('authControllerLogin', 'loginDto', loginDto)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (userAgent != null) {
                localVarHeaderParameter['user-agent'] = String(userAgent);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke the current refresh token, effectively logging out the user
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exchange a valid refresh token for a new access token and refresh token pair
         * @summary Refresh access token
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshTokens: async (refreshTokenDto: RefreshTokenDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenDto' is not null or undefined
            assertParamExists('authControllerRefreshTokens', 'refreshTokenDto', refreshTokenDto)
            const localVarPath = `/api/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister: async (registerDto: RegisterDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerDto' is not null or undefined
            assertParamExists('authControllerRegister', 'registerDto', registerDto)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset password using OTP
         * @param {ResetPasswordWithOTPEmailDto} resetPasswordWithOTPEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPasswordWithOTP: async (resetPasswordWithOTPEmailDto: ResetPasswordWithOTPEmailDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordWithOTPEmailDto' is not null or undefined
            assertParamExists('authControllerResetPasswordWithOTP', 'resetPasswordWithOTPEmailDto', resetPasswordWithOTPEmailDto)
            const localVarPath = `/api/auth/forgot-password/email/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordWithOTPEmailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke a specific session by its ID
         * @summary Revoke specific session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRevokeSession: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('authControllerRevokeSession', 'sessionId', sessionId)
            const localVarPath = `/api/auth/sessions/{sessionId}/revoke`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user profile
         * @param {UpdateProfileDto} updateProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerUpdateProfile: async (updateProfileDto: UpdateProfileDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateProfileDto' is not null or undefined
            assertParamExists('authControllerUpdateProfile', 'updateProfileDto', updateProfileDto)
            const localVarPath = `/api/auth/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProfileDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify email with OTP code
         * @param {VerifyEmailDto} verifyEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyEmail: async (verifyEmailDto: VerifyEmailDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyEmailDto' is not null or undefined
            assertParamExists('authControllerVerifyEmail', 'verifyEmailDto', verifyEmailDto)
            const localVarPath = `/api/auth/verify-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyEmailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Change user password
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerChangePassword(changePasswordDto: ChangePasswordDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerChangePassword(changePasswordDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerChangePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all active sessions for the current user
         * @summary Get active sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetActiveSessions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetActiveSessions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetActiveSessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get analytics data for user sessions. Requires ADMIN role.
         * @summary Get session analytics
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetSessionAnalytics(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetSessionAnalytics(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetSessionAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get suspicious activities for a specific user. Requires ADMIN role.
         * @summary Get suspicious activities
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetSuspiciousActivities(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetSuspiciousActivities(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetSuspiciousActivities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Initiate forgot password process
         * @param {InitiateForgotPasswordEmailDto} initiateForgotPasswordEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerInitiateForgotPassword(initiateForgotPasswordEmailDto: InitiateForgotPasswordEmailDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerInitiateForgotPassword(initiateForgotPasswordEmailDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerInitiateForgotPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userAgent 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(userAgent: string, loginDto: LoginDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(userAgent, loginDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke the current refresh token, effectively logging out the user
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogoutResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exchange a valid refresh token for a new access token and refresh token pair
         * @summary Refresh access token
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefreshTokens(refreshTokenDto: RefreshTokenDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefreshTokens(refreshTokenDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerRefreshTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRegister(registerDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset password using OTP
         * @param {ResetPasswordWithOTPEmailDto} resetPasswordWithOTPEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerResetPasswordWithOTP(resetPasswordWithOTPEmailDto: ResetPasswordWithOTPEmailDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerResetPasswordWithOTP(resetPasswordWithOTPEmailDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerResetPasswordWithOTP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke a specific session by its ID
         * @summary Revoke specific session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRevokeSession(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RevokeSessionResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRevokeSession(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerRevokeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user profile
         * @param {UpdateProfileDto} updateProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerUpdateProfile(updateProfileDto: UpdateProfileDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerUpdateProfile(updateProfileDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerUpdateProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify email with OTP code
         * @param {VerifyEmailDto} verifyEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerVerifyEmail(verifyEmailDto: VerifyEmailDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerVerifyEmail(verifyEmailDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerVerifyEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Change user password
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerChangePassword(changePasswordDto: ChangePasswordDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerChangePassword(changePasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all active sessions for the current user
         * @summary Get active sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetActiveSessions(options?: RawAxiosRequestConfig): AxiosPromise<SessionResponseDto> {
            return localVarFp.authControllerGetActiveSessions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.authControllerGetProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * Get analytics data for user sessions. Requires ADMIN role.
         * @summary Get session analytics
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetSessionAnalytics(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerGetSessionAnalytics(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get suspicious activities for a specific user. Requires ADMIN role.
         * @summary Get suspicious activities
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetSuspiciousActivities(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerGetSuspiciousActivities(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initiate forgot password process
         * @param {InitiateForgotPasswordEmailDto} initiateForgotPasswordEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerInitiateForgotPassword(initiateForgotPasswordEmailDto: InitiateForgotPasswordEmailDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerInitiateForgotPassword(initiateForgotPasswordEmailDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userAgent 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(userAgent: string, loginDto: LoginDto, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponseDto> {
            return localVarFp.authControllerLogin(userAgent, loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke the current refresh token, effectively logging out the user
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout(options?: RawAxiosRequestConfig): AxiosPromise<LogoutResponseDto> {
            return localVarFp.authControllerLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * Exchange a valid refresh token for a new access token and refresh token pair
         * @summary Refresh access token
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshTokens(refreshTokenDto: RefreshTokenDto, options?: RawAxiosRequestConfig): AxiosPromise<RefreshTokenResponseDto> {
            return localVarFp.authControllerRefreshTokens(refreshTokenDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig): AxiosPromise<RegisterResponseDto> {
            return localVarFp.authControllerRegister(registerDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset password using OTP
         * @param {ResetPasswordWithOTPEmailDto} resetPasswordWithOTPEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPasswordWithOTP(resetPasswordWithOTPEmailDto: ResetPasswordWithOTPEmailDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerResetPasswordWithOTP(resetPasswordWithOTPEmailDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke a specific session by its ID
         * @summary Revoke specific session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRevokeSession(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<RevokeSessionResponseDto> {
            return localVarFp.authControllerRevokeSession(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user profile
         * @param {UpdateProfileDto} updateProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerUpdateProfile(updateProfileDto: UpdateProfileDto, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.authControllerUpdateProfile(updateProfileDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify email with OTP code
         * @param {VerifyEmailDto} verifyEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyEmail(verifyEmailDto: VerifyEmailDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerVerifyEmail(verifyEmailDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Change user password
     * @param {ChangePasswordDto} changePasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerChangePassword(changePasswordDto: ChangePasswordDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerChangePassword(changePasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all active sessions for the current user
     * @summary Get active sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetActiveSessions(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetActiveSessions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetProfile(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get analytics data for user sessions. Requires ADMIN role.
     * @summary Get session analytics
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetSessionAnalytics(userId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetSessionAnalytics(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get suspicious activities for a specific user. Requires ADMIN role.
     * @summary Get suspicious activities
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetSuspiciousActivities(userId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetSuspiciousActivities(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initiate forgot password process
     * @param {InitiateForgotPasswordEmailDto} initiateForgotPasswordEmailDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerInitiateForgotPassword(initiateForgotPasswordEmailDto: InitiateForgotPasswordEmailDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerInitiateForgotPassword(initiateForgotPasswordEmailDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userAgent 
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogin(userAgent: string, loginDto: LoginDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogin(userAgent, loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke the current refresh token, effectively logging out the user
     * @summary Logout user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogout(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exchange a valid refresh token for a new access token and refresh token pair
     * @summary Refresh access token
     * @param {RefreshTokenDto} refreshTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRefreshTokens(refreshTokenDto: RefreshTokenDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRefreshTokens(refreshTokenDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterDto} registerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRegister(registerDto: RegisterDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRegister(registerDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset password using OTP
     * @param {ResetPasswordWithOTPEmailDto} resetPasswordWithOTPEmailDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerResetPasswordWithOTP(resetPasswordWithOTPEmailDto: ResetPasswordWithOTPEmailDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerResetPasswordWithOTP(resetPasswordWithOTPEmailDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke a specific session by its ID
     * @summary Revoke specific session
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRevokeSession(sessionId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRevokeSession(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user profile
     * @param {UpdateProfileDto} updateProfileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerUpdateProfile(updateProfileDto: UpdateProfileDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerUpdateProfile(updateProfileDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify email with OTP code
     * @param {VerifyEmailDto} verifyEmailDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerVerifyEmail(verifyEmailDto: VerifyEmailDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerVerifyEmail(verifyEmailDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BookingApi - axios parameter creator
 * @export
 */
export const BookingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new booking directly at the hotel
         * @param {CreateBookingAtHotelDto} createBookingAtHotelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingControllerCreateBookingDirectly: async (createBookingAtHotelDto: CreateBookingAtHotelDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBookingAtHotelDto' is not null or undefined
            assertParamExists('bookingControllerCreateBookingDirectly', 'createBookingAtHotelDto', createBookingAtHotelDto)
            const localVarPath = `/api/booking/directly`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBookingAtHotelDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new booking online
         * @param {CreateBookingOnlineDto} createBookingOnlineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingControllerCreateBookingOnline: async (createBookingOnlineDto: CreateBookingOnlineDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBookingOnlineDto' is not null or undefined
            assertParamExists('bookingControllerCreateBookingOnline', 'createBookingOnlineDto', createBookingOnlineDto)
            const localVarPath = `/api/booking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBookingOnlineDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get booking details
         * @param {string} bookingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingControllerFindById: async (bookingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookingId' is not null or undefined
            assertParamExists('bookingControllerFindById', 'bookingId', bookingId)
            const localVarPath = `/api/booking/{bookingId}`
                .replace(`{${"bookingId"}}`, encodeURIComponent(String(bookingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all bookings with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterBookingsDto
         * @param {string} [sort] JSON string of SortBookingsDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingControllerGetBookings: async (page?: number, pageSize?: number, filters?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/booking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all my bookings with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {FilterMyBookingsDto} [filters] Filter my bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingControllerGetMyBookings: async (page?: number, pageSize?: number, filters?: FilterMyBookingsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/booking/my-bookings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                for (const [key, value] of Object.entries(filters)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update booking status
         * @param {string} bookingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingControllerUpdateBookingStatus: async (bookingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookingId' is not null or undefined
            assertParamExists('bookingControllerUpdateBookingStatus', 'bookingId', bookingId)
            const localVarPath = `/api/booking/update-status/{bookingId}`
                .replace(`{${"bookingId"}}`, encodeURIComponent(String(bookingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookingApi - functional programming interface
 * @export
 */
export const BookingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new booking directly at the hotel
         * @param {CreateBookingAtHotelDto} createBookingAtHotelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookingControllerCreateBookingDirectly(createBookingAtHotelDto: CreateBookingAtHotelDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Booking>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookingControllerCreateBookingDirectly(createBookingAtHotelDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookingApi.bookingControllerCreateBookingDirectly']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new booking online
         * @param {CreateBookingOnlineDto} createBookingOnlineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookingControllerCreateBookingOnline(createBookingOnlineDto: CreateBookingOnlineDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Booking>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookingControllerCreateBookingOnline(createBookingOnlineDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookingApi.bookingControllerCreateBookingOnline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get booking details
         * @param {string} bookingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookingControllerFindById(bookingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Booking>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookingControllerFindById(bookingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookingApi.bookingControllerFindById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all bookings with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterBookingsDto
         * @param {string} [sort] JSON string of SortBookingsDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookingControllerGetBookings(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookingsPaginationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookingControllerGetBookings(page, pageSize, filters, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookingApi.bookingControllerGetBookings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all my bookings with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {FilterMyBookingsDto} [filters] Filter my bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookingControllerGetMyBookings(page?: number, pageSize?: number, filters?: FilterMyBookingsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookingsPaginationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookingControllerGetMyBookings(page, pageSize, filters, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookingApi.bookingControllerGetMyBookings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update booking status
         * @param {string} bookingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookingControllerUpdateBookingStatus(bookingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Booking>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookingControllerUpdateBookingStatus(bookingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookingApi.bookingControllerUpdateBookingStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BookingApi - factory interface
 * @export
 */
export const BookingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookingApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new booking directly at the hotel
         * @param {CreateBookingAtHotelDto} createBookingAtHotelDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingControllerCreateBookingDirectly(createBookingAtHotelDto: CreateBookingAtHotelDto, options?: RawAxiosRequestConfig): AxiosPromise<Booking> {
            return localVarFp.bookingControllerCreateBookingDirectly(createBookingAtHotelDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new booking online
         * @param {CreateBookingOnlineDto} createBookingOnlineDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingControllerCreateBookingOnline(createBookingOnlineDto: CreateBookingOnlineDto, options?: RawAxiosRequestConfig): AxiosPromise<Booking> {
            return localVarFp.bookingControllerCreateBookingOnline(createBookingOnlineDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get booking details
         * @param {string} bookingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingControllerFindById(bookingId: string, options?: RawAxiosRequestConfig): AxiosPromise<Booking> {
            return localVarFp.bookingControllerFindById(bookingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all bookings with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterBookingsDto
         * @param {string} [sort] JSON string of SortBookingsDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingControllerGetBookings(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<BookingsPaginationResultDto> {
            return localVarFp.bookingControllerGetBookings(page, pageSize, filters, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all my bookings with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {FilterMyBookingsDto} [filters] Filter my bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingControllerGetMyBookings(page?: number, pageSize?: number, filters?: FilterMyBookingsDto, options?: RawAxiosRequestConfig): AxiosPromise<BookingsPaginationResultDto> {
            return localVarFp.bookingControllerGetMyBookings(page, pageSize, filters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update booking status
         * @param {string} bookingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookingControllerUpdateBookingStatus(bookingId: string, options?: RawAxiosRequestConfig): AxiosPromise<Booking> {
            return localVarFp.bookingControllerUpdateBookingStatus(bookingId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookingApi - object-oriented interface
 * @export
 * @class BookingApi
 * @extends {BaseAPI}
 */
export class BookingApi extends BaseAPI {
    /**
     * 
     * @summary Create a new booking directly at the hotel
     * @param {CreateBookingAtHotelDto} createBookingAtHotelDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingApi
     */
    public bookingControllerCreateBookingDirectly(createBookingAtHotelDto: CreateBookingAtHotelDto, options?: RawAxiosRequestConfig) {
        return BookingApiFp(this.configuration).bookingControllerCreateBookingDirectly(createBookingAtHotelDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new booking online
     * @param {CreateBookingOnlineDto} createBookingOnlineDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingApi
     */
    public bookingControllerCreateBookingOnline(createBookingOnlineDto: CreateBookingOnlineDto, options?: RawAxiosRequestConfig) {
        return BookingApiFp(this.configuration).bookingControllerCreateBookingOnline(createBookingOnlineDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get booking details
     * @param {string} bookingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingApi
     */
    public bookingControllerFindById(bookingId: string, options?: RawAxiosRequestConfig) {
        return BookingApiFp(this.configuration).bookingControllerFindById(bookingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all bookings with pagination and filters
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [filters] JSON string of FilterBookingsDto
     * @param {string} [sort] JSON string of SortBookingsDto[]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingApi
     */
    public bookingControllerGetBookings(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return BookingApiFp(this.configuration).bookingControllerGetBookings(page, pageSize, filters, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all my bookings with pagination and filters
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {FilterMyBookingsDto} [filters] Filter my bookings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingApi
     */
    public bookingControllerGetMyBookings(page?: number, pageSize?: number, filters?: FilterMyBookingsDto, options?: RawAxiosRequestConfig) {
        return BookingApiFp(this.configuration).bookingControllerGetMyBookings(page, pageSize, filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update booking status
     * @param {string} bookingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingApi
     */
    public bookingControllerUpdateBookingStatus(bookingId: string, options?: RawAxiosRequestConfig) {
        return BookingApiFp(this.configuration).bookingControllerUpdateBookingStatus(bookingId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BranchesApi - axios parameter creator
 * @export
 */
export const BranchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new branch
         * @param {CreateBranchDto} createBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerCreate: async (createBranchDto: CreateBranchDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBranchDto' is not null or undefined
            assertParamExists('branchControllerCreate', 'createBranchDto', createBranchDto)
            const localVarPath = `/api/branches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBranchDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all soft-deleted branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindDeleted: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/branches/deleted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all branches with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterBranchesDto
         * @param {string} [sort] JSON string of SortBranchDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindMany: async (page?: number, pageSize?: number, filters?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/branches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get branches with infinite scroll for client app
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterBranchesDto
         * @param {string} [sort] JSON string of SortBranchDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindManyInfinite: async (page?: number, pageSize?: number, filters?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/branches/infinite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get branch by ID or slug
         * @param {string} idOrSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindOne: async (idOrSlug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idOrSlug' is not null or undefined
            assertParamExists('branchControllerFindOne', 'idOrSlug', idOrSlug)
            const localVarPath = `/api/branches/{idOrSlug}`
                .replace(`{${"idOrSlug"}}`, encodeURIComponent(String(idOrSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get latest branches
         * @param {number} [limit] Number of branches to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerGetLatestBranches: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/branches/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a branch
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('branchControllerRemove', 'id', id)
            const localVarPath = `/api/branches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a soft-deleted branch
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerRestore: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('branchControllerRestore', 'id', id)
            const localVarPath = `/api/branches/{id}/restore`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a branch
         * @param {string} id 
         * @param {UpdateBranchDto} updateBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerUpdate: async (id: string, updateBranchDto: UpdateBranchDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('branchControllerUpdate', 'id', id)
            // verify required parameter 'updateBranchDto' is not null or undefined
            assertParamExists('branchControllerUpdate', 'updateBranchDto', updateBranchDto)
            const localVarPath = `/api/branches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBranchDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BranchesApi - functional programming interface
 * @export
 */
export const BranchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BranchesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new branch
         * @param {CreateBranchDto} createBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerCreate(createBranchDto: CreateBranchDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerCreate(createBranchDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all soft-deleted branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerFindDeleted(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Branch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerFindDeleted(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerFindDeleted']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all branches with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterBranchesDto
         * @param {string} [sort] JSON string of SortBranchDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchesPaginationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerFindMany(page, pageSize, filters, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get branches with infinite scroll for client app
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterBranchesDto
         * @param {string} [sort] JSON string of SortBranchDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerFindManyInfinite(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchesInfinitePaginationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerFindManyInfinite(page, pageSize, filters, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerFindManyInfinite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get branch by ID or slug
         * @param {string} idOrSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerFindOne(idOrSlug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerFindOne(idOrSlug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get latest branches
         * @param {number} [limit] Number of branches to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerGetLatestBranches(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Branch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerGetLatestBranches(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerGetLatestBranches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a branch
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Restore a soft-deleted branch
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerRestore(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerRestore(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a branch
         * @param {string} id 
         * @param {UpdateBranchDto} updateBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchControllerUpdate(id: string, updateBranchDto: UpdateBranchDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchControllerUpdate(id, updateBranchDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.branchControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BranchesApi - factory interface
 * @export
 */
export const BranchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BranchesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new branch
         * @param {CreateBranchDto} createBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerCreate(createBranchDto: CreateBranchDto, options?: RawAxiosRequestConfig): AxiosPromise<Branch> {
            return localVarFp.branchControllerCreate(createBranchDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all soft-deleted branches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindDeleted(options?: RawAxiosRequestConfig): AxiosPromise<Array<Branch>> {
            return localVarFp.branchControllerFindDeleted(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all branches with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterBranchesDto
         * @param {string} [sort] JSON string of SortBranchDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<BranchesPaginationResultDto> {
            return localVarFp.branchControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get branches with infinite scroll for client app
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterBranchesDto
         * @param {string} [sort] JSON string of SortBranchDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindManyInfinite(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<BranchesInfinitePaginationResultDto> {
            return localVarFp.branchControllerFindManyInfinite(page, pageSize, filters, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get branch by ID or slug
         * @param {string} idOrSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerFindOne(idOrSlug: string, options?: RawAxiosRequestConfig): AxiosPromise<BranchDetail> {
            return localVarFp.branchControllerFindOne(idOrSlug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get latest branches
         * @param {number} [limit] Number of branches to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerGetLatestBranches(limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Branch>> {
            return localVarFp.branchControllerGetLatestBranches(limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a branch
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.branchControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a soft-deleted branch
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerRestore(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.branchControllerRestore(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a branch
         * @param {string} id 
         * @param {UpdateBranchDto} updateBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchControllerUpdate(id: string, updateBranchDto: UpdateBranchDto, options?: RawAxiosRequestConfig): AxiosPromise<Branch> {
            return localVarFp.branchControllerUpdate(id, updateBranchDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BranchesApi - object-oriented interface
 * @export
 * @class BranchesApi
 * @extends {BaseAPI}
 */
export class BranchesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new branch
     * @param {CreateBranchDto} createBranchDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerCreate(createBranchDto: CreateBranchDto, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerCreate(createBranchDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all soft-deleted branches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerFindDeleted(options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerFindDeleted(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all branches with pagination and filters
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [filters] JSON string of FilterBranchesDto
     * @param {string} [sort] JSON string of SortBranchDto[]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get branches with infinite scroll for client app
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [filters] JSON string of FilterBranchesDto
     * @param {string} [sort] JSON string of SortBranchDto[]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerFindManyInfinite(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerFindManyInfinite(page, pageSize, filters, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get branch by ID or slug
     * @param {string} idOrSlug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerFindOne(idOrSlug: string, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerFindOne(idOrSlug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get latest branches
     * @param {number} [limit] Number of branches to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerGetLatestBranches(limit?: number, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerGetLatestBranches(limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a branch
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a soft-deleted branch
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerRestore(id: string, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerRestore(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a branch
     * @param {string} id 
     * @param {UpdateBranchDto} updateBranchDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchControllerUpdate(id: string, updateBranchDto: UpdateBranchDto, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchControllerUpdate(id, updateBranchDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EmailApi - axios parameter creator
 * @export
 */
export const EmailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send verification email
         * @param {VerificationEmailDto} verificationEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailControllerSendVerificationEmail: async (verificationEmailDto: VerificationEmailDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verificationEmailDto' is not null or undefined
            assertParamExists('emailControllerSendVerificationEmail', 'verificationEmailDto', verificationEmailDto)
            const localVarPath = `/api/email/send-verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verificationEmailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailApi - functional programming interface
 * @export
 */
export const EmailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmailApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Send verification email
         * @param {VerificationEmailDto} verificationEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailControllerSendVerificationEmail(verificationEmailDto: VerificationEmailDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailControllerSendVerificationEmail(verificationEmailDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmailApi.emailControllerSendVerificationEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EmailApi - factory interface
 * @export
 */
export const EmailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmailApiFp(configuration)
    return {
        /**
         * 
         * @summary Send verification email
         * @param {VerificationEmailDto} verificationEmailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailControllerSendVerificationEmail(verificationEmailDto: VerificationEmailDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.emailControllerSendVerificationEmail(verificationEmailDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmailApi - object-oriented interface
 * @export
 * @class EmailApi
 * @extends {BaseAPI}
 */
export class EmailApi extends BaseAPI {
    /**
     * 
     * @summary Send verification email
     * @param {VerificationEmailDto} verificationEmailDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApi
     */
    public emailControllerSendVerificationEmail(verificationEmailDto: VerificationEmailDto, options?: RawAxiosRequestConfig) {
        return EmailApiFp(this.configuration).emailControllerSendVerificationEmail(verificationEmailDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get image by public id
         * @param {string} publicId Public ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetImageByPublicId: async (publicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicId' is not null or undefined
            assertParamExists('imagesControllerGetImageByPublicId', 'publicId', publicId)
            const localVarPath = `/api/images/{publicId}`
                .replace(`{${"publicId"}}`, encodeURIComponent(String(publicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload amenity icon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerUploadIcon: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/images/icon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload multiple image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerUploadImages: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get image by public id
         * @param {string} publicId Public ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerGetImageByPublicId(publicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerGetImageByPublicId(publicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerGetImageByPublicId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload amenity icon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerUploadIcon(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUploadResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerUploadIcon(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerUploadIcon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload multiple image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesControllerUploadImages(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageUploadResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesControllerUploadImages(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.imagesControllerUploadImages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get image by public id
         * @param {string} publicId Public ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerGetImageByPublicId(publicId: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadResponseDto> {
            return localVarFp.imagesControllerGetImageByPublicId(publicId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload amenity icon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerUploadIcon(options?: RawAxiosRequestConfig): AxiosPromise<ImageUploadResponseDto> {
            return localVarFp.imagesControllerUploadIcon(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload multiple image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesControllerUploadImages(options?: RawAxiosRequestConfig): AxiosPromise<Array<ImageUploadResponseDto>> {
            return localVarFp.imagesControllerUploadImages(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
    /**
     * 
     * @summary Get image by public id
     * @param {string} publicId Public ID of the image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerGetImageByPublicId(publicId: string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerGetImageByPublicId(publicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload amenity icon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerUploadIcon(options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerUploadIcon(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload multiple image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesControllerUploadImages(options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesControllerUploadImages(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * POEditorApi - axios parameter creator
 * @export
 */
export const POEditorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add translations to POEditor project
         * @param {AddTranslationDto} addTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poeditorControllerAddTranslation: async (addTranslationDto: AddTranslationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addTranslationDto' is not null or undefined
            assertParamExists('poeditorControllerAddTranslation', 'addTranslationDto', addTranslationDto)
            const localVarPath = `/api/poeditor/translations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addTranslationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get translations from POEditor project
         * @param {GetTranslationsRequestDto} getTranslationsRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poeditorControllerGetTranslations: async (getTranslationsRequestDto: GetTranslationsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getTranslationsRequestDto' is not null or undefined
            assertParamExists('poeditorControllerGetTranslations', 'getTranslationsRequestDto', getTranslationsRequestDto)
            const localVarPath = `/api/poeditor/translations-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getTranslationsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * POEditorApi - functional programming interface
 * @export
 */
export const POEditorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = POEditorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add translations to POEditor project
         * @param {AddTranslationDto} addTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async poeditorControllerAddTranslation(addTranslationDto: AddTranslationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.poeditorControllerAddTranslation(addTranslationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['POEditorApi.poeditorControllerAddTranslation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get translations from POEditor project
         * @param {GetTranslationsRequestDto} getTranslationsRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async poeditorControllerGetTranslations(getTranslationsRequestDto: GetTranslationsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTranslationResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.poeditorControllerGetTranslations(getTranslationsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['POEditorApi.poeditorControllerGetTranslations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * POEditorApi - factory interface
 * @export
 */
export const POEditorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = POEditorApiFp(configuration)
    return {
        /**
         * 
         * @summary Add translations to POEditor project
         * @param {AddTranslationDto} addTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poeditorControllerAddTranslation(addTranslationDto: AddTranslationDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.poeditorControllerAddTranslation(addTranslationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get translations from POEditor project
         * @param {GetTranslationsRequestDto} getTranslationsRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poeditorControllerGetTranslations(getTranslationsRequestDto: GetTranslationsRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<ListTranslationResponseDto> {
            return localVarFp.poeditorControllerGetTranslations(getTranslationsRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * POEditorApi - object-oriented interface
 * @export
 * @class POEditorApi
 * @extends {BaseAPI}
 */
export class POEditorApi extends BaseAPI {
    /**
     * 
     * @summary Add translations to POEditor project
     * @param {AddTranslationDto} addTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof POEditorApi
     */
    public poeditorControllerAddTranslation(addTranslationDto: AddTranslationDto, options?: RawAxiosRequestConfig) {
        return POEditorApiFp(this.configuration).poeditorControllerAddTranslation(addTranslationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get translations from POEditor project
     * @param {GetTranslationsRequestDto} getTranslationsRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof POEditorApi
     */
    public poeditorControllerGetTranslations(getTranslationsRequestDto: GetTranslationsRequestDto, options?: RawAxiosRequestConfig) {
        return POEditorApiFp(this.configuration).poeditorControllerGetTranslations(getTranslationsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProvincesApi - axios parameter creator
 * @export
 */
export const ProvincesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new province
         * @param {CreateProvinceDto} createProvinceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerCreate: async (createProvinceDto: CreateProvinceDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProvinceDto' is not null or undefined
            assertParamExists('provincesControllerCreate', 'createProvinceDto', createProvinceDto)
            const localVarPath = `/api/provinces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProvinceDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all soft-deleted provinces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerFindDeleted: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/provinces/deleted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all provinces with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterProvincesDto
         * @param {string} [sort] JSON string of SortProvinceDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerFindMany: async (page?: number, pageSize?: number, filters?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/provinces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get province by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('provincesControllerFindOne', 'id', id)
            const localVarPath = `/api/provinces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a province
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('provincesControllerRemove', 'id', id)
            const localVarPath = `/api/provinces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a soft-deleted province
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerRestore: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('provincesControllerRestore', 'id', id)
            const localVarPath = `/api/provinces/{id}/restore`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a province
         * @param {string} id 
         * @param {UpdateProvinceDto} updateProvinceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerUpdate: async (id: string, updateProvinceDto: UpdateProvinceDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('provincesControllerUpdate', 'id', id)
            // verify required parameter 'updateProvinceDto' is not null or undefined
            assertParamExists('provincesControllerUpdate', 'updateProvinceDto', updateProvinceDto)
            const localVarPath = `/api/provinces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProvinceDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvincesApi - functional programming interface
 * @export
 */
export const ProvincesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProvincesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new province
         * @param {CreateProvinceDto} createProvinceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provincesControllerCreate(createProvinceDto: CreateProvinceDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Province>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provincesControllerCreate(createProvinceDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvincesApi.provincesControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all soft-deleted provinces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provincesControllerFindDeleted(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Province>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provincesControllerFindDeleted(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvincesApi.provincesControllerFindDeleted']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all provinces with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterProvincesDto
         * @param {string} [sort] JSON string of SortProvinceDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provincesControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvincePaginationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provincesControllerFindMany(page, pageSize, filters, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvincesApi.provincesControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get province by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provincesControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Province>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provincesControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvincesApi.provincesControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a province
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provincesControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provincesControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvincesApi.provincesControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Restore a soft-deleted province
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provincesControllerRestore(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provincesControllerRestore(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvincesApi.provincesControllerRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a province
         * @param {string} id 
         * @param {UpdateProvinceDto} updateProvinceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provincesControllerUpdate(id: string, updateProvinceDto: UpdateProvinceDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Province>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provincesControllerUpdate(id, updateProvinceDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvincesApi.provincesControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProvincesApi - factory interface
 * @export
 */
export const ProvincesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProvincesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new province
         * @param {CreateProvinceDto} createProvinceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerCreate(createProvinceDto: CreateProvinceDto, options?: RawAxiosRequestConfig): AxiosPromise<Province> {
            return localVarFp.provincesControllerCreate(createProvinceDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all soft-deleted provinces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerFindDeleted(options?: RawAxiosRequestConfig): AxiosPromise<Array<Province>> {
            return localVarFp.provincesControllerFindDeleted(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all provinces with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterProvincesDto
         * @param {string} [sort] JSON string of SortProvinceDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProvincePaginationResultDto> {
            return localVarFp.provincesControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get province by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Province> {
            return localVarFp.provincesControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a province
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.provincesControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a soft-deleted province
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerRestore(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.provincesControllerRestore(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a province
         * @param {string} id 
         * @param {UpdateProvinceDto} updateProvinceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provincesControllerUpdate(id: string, updateProvinceDto: UpdateProvinceDto, options?: RawAxiosRequestConfig): AxiosPromise<Province> {
            return localVarFp.provincesControllerUpdate(id, updateProvinceDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvincesApi - object-oriented interface
 * @export
 * @class ProvincesApi
 * @extends {BaseAPI}
 */
export class ProvincesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new province
     * @param {CreateProvinceDto} createProvinceDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvincesApi
     */
    public provincesControllerCreate(createProvinceDto: CreateProvinceDto, options?: RawAxiosRequestConfig) {
        return ProvincesApiFp(this.configuration).provincesControllerCreate(createProvinceDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all soft-deleted provinces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvincesApi
     */
    public provincesControllerFindDeleted(options?: RawAxiosRequestConfig) {
        return ProvincesApiFp(this.configuration).provincesControllerFindDeleted(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all provinces with pagination and filters
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [filters] JSON string of FilterProvincesDto
     * @param {string} [sort] JSON string of SortProvinceDto[]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvincesApi
     */
    public provincesControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return ProvincesApiFp(this.configuration).provincesControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get province by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvincesApi
     */
    public provincesControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return ProvincesApiFp(this.configuration).provincesControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a province
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvincesApi
     */
    public provincesControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return ProvincesApiFp(this.configuration).provincesControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a soft-deleted province
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvincesApi
     */
    public provincesControllerRestore(id: string, options?: RawAxiosRequestConfig) {
        return ProvincesApiFp(this.configuration).provincesControllerRestore(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a province
     * @param {string} id 
     * @param {UpdateProvinceDto} updateProvinceDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvincesApi
     */
    public provincesControllerUpdate(id: string, updateProvinceDto: UpdateProvinceDto, options?: RawAxiosRequestConfig) {
        return ProvincesApiFp(this.configuration).provincesControllerUpdate(id, updateProvinceDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoomDetailsApi - axios parameter creator
 * @export
 */
export const RoomDetailsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new room detail
         * @param {CreateRoomDetailDto} createRoomDetailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerCreate: async (createRoomDetailDto: CreateRoomDetailDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRoomDetailDto' is not null or undefined
            assertParamExists('roomDetailControllerCreate', 'createRoomDetailDto', createRoomDetailDto)
            const localVarPath = `/api/room-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoomDetailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all soft-deleted room details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerFindDeleted: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/room-details/deleted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all room details with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterRoomDetailDto
         * @param {Array<string>} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerFindMany: async (page?: number, pageSize?: number, filters?: string, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/room-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all room details with infinite pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterRoomDetailDto
         * @param {Array<string>} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerFindManyInfinite: async (page?: number, pageSize?: number, filters?: string, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/room-details/infinite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a room detail by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('roomDetailControllerFindOne', 'id', id)
            const localVarPath = `/api/room-details/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a room detail
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('roomDetailControllerRemove', 'id', id)
            const localVarPath = `/api/room-details/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a soft-deleted room detail
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerRestore: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('roomDetailControllerRestore', 'id', id)
            const localVarPath = `/api/room-details/{id}/restore`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a room detail
         * @param {string} id 
         * @param {UpdateRoomDetailDto} updateRoomDetailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerUpdate: async (id: string, updateRoomDetailDto: UpdateRoomDetailDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('roomDetailControllerUpdate', 'id', id)
            // verify required parameter 'updateRoomDetailDto' is not null or undefined
            assertParamExists('roomDetailControllerUpdate', 'updateRoomDetailDto', updateRoomDetailDto)
            const localVarPath = `/api/room-details/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoomDetailDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomDetailsApi - functional programming interface
 * @export
 */
export const RoomDetailsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomDetailsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new room detail
         * @param {CreateRoomDetailDto} createRoomDetailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomDetailControllerCreate(createRoomDetailDto: CreateRoomDetailDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomDetailControllerCreate(createRoomDetailDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomDetailsApi.roomDetailControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all soft-deleted room details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomDetailControllerFindDeleted(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDetail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomDetailControllerFindDeleted(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomDetailsApi.roomDetailControllerFindDeleted']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all room details with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterRoomDetailDto
         * @param {Array<string>} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomDetailControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDetailPaginationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomDetailControllerFindMany(page, pageSize, filters, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomDetailsApi.roomDetailControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all room details with infinite pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterRoomDetailDto
         * @param {Array<string>} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomDetailControllerFindManyInfinite(page?: number, pageSize?: number, filters?: string, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDetailInfinitePaginationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomDetailControllerFindManyInfinite(page, pageSize, filters, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomDetailsApi.roomDetailControllerFindManyInfinite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a room detail by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomDetailControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomDetailControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomDetailsApi.roomDetailControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a room detail
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomDetailControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomDetailControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomDetailsApi.roomDetailControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Restore a soft-deleted room detail
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomDetailControllerRestore(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomDetailControllerRestore(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomDetailsApi.roomDetailControllerRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a room detail
         * @param {string} id 
         * @param {UpdateRoomDetailDto} updateRoomDetailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomDetailControllerUpdate(id: string, updateRoomDetailDto: UpdateRoomDetailDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomDetailControllerUpdate(id, updateRoomDetailDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomDetailsApi.roomDetailControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoomDetailsApi - factory interface
 * @export
 */
export const RoomDetailsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomDetailsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new room detail
         * @param {CreateRoomDetailDto} createRoomDetailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerCreate(createRoomDetailDto: CreateRoomDetailDto, options?: RawAxiosRequestConfig): AxiosPromise<RoomDetail> {
            return localVarFp.roomDetailControllerCreate(createRoomDetailDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all soft-deleted room details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerFindDeleted(options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomDetail>> {
            return localVarFp.roomDetailControllerFindDeleted(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all room details with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterRoomDetailDto
         * @param {Array<string>} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<RoomDetailPaginationResultDto> {
            return localVarFp.roomDetailControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all room details with infinite pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterRoomDetailDto
         * @param {Array<string>} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerFindManyInfinite(page?: number, pageSize?: number, filters?: string, sort?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<RoomDetailInfinitePaginationResultDto> {
            return localVarFp.roomDetailControllerFindManyInfinite(page, pageSize, filters, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a room detail by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomDetail> {
            return localVarFp.roomDetailControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a room detail
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomDetailControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a soft-deleted room detail
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerRestore(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RoomDetail> {
            return localVarFp.roomDetailControllerRestore(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a room detail
         * @param {string} id 
         * @param {UpdateRoomDetailDto} updateRoomDetailDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomDetailControllerUpdate(id: string, updateRoomDetailDto: UpdateRoomDetailDto, options?: RawAxiosRequestConfig): AxiosPromise<RoomDetail> {
            return localVarFp.roomDetailControllerUpdate(id, updateRoomDetailDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomDetailsApi - object-oriented interface
 * @export
 * @class RoomDetailsApi
 * @extends {BaseAPI}
 */
export class RoomDetailsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new room detail
     * @param {CreateRoomDetailDto} createRoomDetailDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomDetailsApi
     */
    public roomDetailControllerCreate(createRoomDetailDto: CreateRoomDetailDto, options?: RawAxiosRequestConfig) {
        return RoomDetailsApiFp(this.configuration).roomDetailControllerCreate(createRoomDetailDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all soft-deleted room details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomDetailsApi
     */
    public roomDetailControllerFindDeleted(options?: RawAxiosRequestConfig) {
        return RoomDetailsApiFp(this.configuration).roomDetailControllerFindDeleted(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all room details with pagination and filters
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [filters] JSON string of FilterRoomDetailDto
     * @param {Array<string>} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomDetailsApi
     */
    public roomDetailControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return RoomDetailsApiFp(this.configuration).roomDetailControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all room details with infinite pagination and filters
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [filters] JSON string of FilterRoomDetailDto
     * @param {Array<string>} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomDetailsApi
     */
    public roomDetailControllerFindManyInfinite(page?: number, pageSize?: number, filters?: string, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return RoomDetailsApiFp(this.configuration).roomDetailControllerFindManyInfinite(page, pageSize, filters, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a room detail by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomDetailsApi
     */
    public roomDetailControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return RoomDetailsApiFp(this.configuration).roomDetailControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a room detail
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomDetailsApi
     */
    public roomDetailControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return RoomDetailsApiFp(this.configuration).roomDetailControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a soft-deleted room detail
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomDetailsApi
     */
    public roomDetailControllerRestore(id: string, options?: RawAxiosRequestConfig) {
        return RoomDetailsApiFp(this.configuration).roomDetailControllerRestore(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a room detail
     * @param {string} id 
     * @param {UpdateRoomDetailDto} updateRoomDetailDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomDetailsApi
     */
    public roomDetailControllerUpdate(id: string, updateRoomDetailDto: UpdateRoomDetailDto, options?: RawAxiosRequestConfig) {
        return RoomDetailsApiFp(this.configuration).roomDetailControllerUpdate(id, updateRoomDetailDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoomPriceHistoriesApi - axios parameter creator
 * @export
 */
export const RoomPriceHistoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new room price history
         * @param {CreateRoomPriceHistoryDto} createRoomPriceHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomPriceHistoryControllerCreate: async (createRoomPriceHistoryDto: CreateRoomPriceHistoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRoomPriceHistoryDto' is not null or undefined
            assertParamExists('roomPriceHistoryControllerCreate', 'createRoomPriceHistoryDto', createRoomPriceHistoryDto)
            const localVarPath = `/api/room-price-histories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoomPriceHistoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all price histories for a specific room detail
         * @param {string} roomDetailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomPriceHistoryControllerFindManyByRoomDetail: async (roomDetailId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomDetailId' is not null or undefined
            assertParamExists('roomPriceHistoryControllerFindManyByRoomDetail', 'roomDetailId', roomDetailId)
            const localVarPath = `/api/room-price-histories/room-detail/{roomDetailId}`
                .replace(`{${"roomDetailId"}}`, encodeURIComponent(String(roomDetailId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a room price history
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomPriceHistoryControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('roomPriceHistoryControllerRemove', 'id', id)
            const localVarPath = `/api/room-price-histories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a room price history
         * @param {string} id 
         * @param {UpdateRoomPriceHistoryDto} updateRoomPriceHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomPriceHistoryControllerUpdate: async (id: string, updateRoomPriceHistoryDto: UpdateRoomPriceHistoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('roomPriceHistoryControllerUpdate', 'id', id)
            // verify required parameter 'updateRoomPriceHistoryDto' is not null or undefined
            assertParamExists('roomPriceHistoryControllerUpdate', 'updateRoomPriceHistoryDto', updateRoomPriceHistoryDto)
            const localVarPath = `/api/room-price-histories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoomPriceHistoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomPriceHistoriesApi - functional programming interface
 * @export
 */
export const RoomPriceHistoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomPriceHistoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new room price history
         * @param {CreateRoomPriceHistoryDto} createRoomPriceHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomPriceHistoryControllerCreate(createRoomPriceHistoryDto: CreateRoomPriceHistoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomPriceHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomPriceHistoryControllerCreate(createRoomPriceHistoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomPriceHistoriesApi.roomPriceHistoryControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all price histories for a specific room detail
         * @param {string} roomDetailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomPriceHistoryControllerFindManyByRoomDetail(roomDetailId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomPriceHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomPriceHistoryControllerFindManyByRoomDetail(roomDetailId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomPriceHistoriesApi.roomPriceHistoryControllerFindManyByRoomDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a room price history
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomPriceHistoryControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomPriceHistoryControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomPriceHistoriesApi.roomPriceHistoryControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a room price history
         * @param {string} id 
         * @param {UpdateRoomPriceHistoryDto} updateRoomPriceHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomPriceHistoryControllerUpdate(id: string, updateRoomPriceHistoryDto: UpdateRoomPriceHistoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomPriceHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomPriceHistoryControllerUpdate(id, updateRoomPriceHistoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomPriceHistoriesApi.roomPriceHistoryControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoomPriceHistoriesApi - factory interface
 * @export
 */
export const RoomPriceHistoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomPriceHistoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new room price history
         * @param {CreateRoomPriceHistoryDto} createRoomPriceHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomPriceHistoryControllerCreate(createRoomPriceHistoryDto: CreateRoomPriceHistoryDto, options?: RawAxiosRequestConfig): AxiosPromise<RoomPriceHistory> {
            return localVarFp.roomPriceHistoryControllerCreate(createRoomPriceHistoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all price histories for a specific room detail
         * @param {string} roomDetailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomPriceHistoryControllerFindManyByRoomDetail(roomDetailId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomPriceHistory>> {
            return localVarFp.roomPriceHistoryControllerFindManyByRoomDetail(roomDetailId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a room price history
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomPriceHistoryControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomPriceHistoryControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a room price history
         * @param {string} id 
         * @param {UpdateRoomPriceHistoryDto} updateRoomPriceHistoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomPriceHistoryControllerUpdate(id: string, updateRoomPriceHistoryDto: UpdateRoomPriceHistoryDto, options?: RawAxiosRequestConfig): AxiosPromise<RoomPriceHistory> {
            return localVarFp.roomPriceHistoryControllerUpdate(id, updateRoomPriceHistoryDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomPriceHistoriesApi - object-oriented interface
 * @export
 * @class RoomPriceHistoriesApi
 * @extends {BaseAPI}
 */
export class RoomPriceHistoriesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new room price history
     * @param {CreateRoomPriceHistoryDto} createRoomPriceHistoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomPriceHistoriesApi
     */
    public roomPriceHistoryControllerCreate(createRoomPriceHistoryDto: CreateRoomPriceHistoryDto, options?: RawAxiosRequestConfig) {
        return RoomPriceHistoriesApiFp(this.configuration).roomPriceHistoryControllerCreate(createRoomPriceHistoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all price histories for a specific room detail
     * @param {string} roomDetailId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomPriceHistoriesApi
     */
    public roomPriceHistoryControllerFindManyByRoomDetail(roomDetailId: string, options?: RawAxiosRequestConfig) {
        return RoomPriceHistoriesApiFp(this.configuration).roomPriceHistoryControllerFindManyByRoomDetail(roomDetailId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a room price history
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomPriceHistoriesApi
     */
    public roomPriceHistoryControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return RoomPriceHistoriesApiFp(this.configuration).roomPriceHistoryControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a room price history
     * @param {string} id 
     * @param {UpdateRoomPriceHistoryDto} updateRoomPriceHistoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomPriceHistoriesApi
     */
    public roomPriceHistoryControllerUpdate(id: string, updateRoomPriceHistoryDto: UpdateRoomPriceHistoryDto, options?: RawAxiosRequestConfig) {
        return RoomPriceHistoriesApiFp(this.configuration).roomPriceHistoryControllerUpdate(id, updateRoomPriceHistoryDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoomsApi - axios parameter creator
 * @export
 */
export const RoomsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new room
         * @param {CreateHotelRoomDto} createHotelRoomDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerCreate: async (createHotelRoomDto: CreateHotelRoomDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createHotelRoomDto' is not null or undefined
            assertParamExists('roomControllerCreate', 'createHotelRoomDto', createHotelRoomDto)
            const localVarPath = `/api/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createHotelRoomDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all soft-deleted rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerFindDeleted: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/rooms/deleted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all rooms with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterHotelRoomDto
         * @param {string} [sort] JSON string of SortHotelRoomDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerFindMany: async (page?: number, pageSize?: number, filters?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ADMIN - STAFF Get all rooms by branch ID
         * @param {string} branchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerFindManyByBranchId: async (branchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branchId' is not null or undefined
            assertParamExists('roomControllerFindManyByBranchId', 'branchId', branchId)
            const localVarPath = `/api/rooms/in-branch/{branchId}`
                .replace(`{${"branchId"}}`, encodeURIComponent(String(branchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a room by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('roomControllerFindOne', 'id', id)
            const localVarPath = `/api/rooms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ADMIN - Delete rooms permanently
         * @param {ImmediateDeleteRoomsDto} immediateDeleteRoomsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerPermanentDelete: async (immediateDeleteRoomsDto: ImmediateDeleteRoomsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'immediateDeleteRoomsDto' is not null or undefined
            assertParamExists('roomControllerPermanentDelete', 'immediateDeleteRoomsDto', immediateDeleteRoomsDto)
            const localVarPath = `/api/rooms/permanent-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(immediateDeleteRoomsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a room
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('roomControllerRemove', 'id', id)
            const localVarPath = `/api/rooms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a soft-deleted room
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerRestore: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('roomControllerRestore', 'id', id)
            const localVarPath = `/api/rooms/{id}/restore`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a room
         * @param {string} id 
         * @param {UpdateHotelRoomDto} updateHotelRoomDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerUpdate: async (id: string, updateHotelRoomDto: UpdateHotelRoomDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('roomControllerUpdate', 'id', id)
            // verify required parameter 'updateHotelRoomDto' is not null or undefined
            assertParamExists('roomControllerUpdate', 'updateHotelRoomDto', updateHotelRoomDto)
            const localVarPath = `/api/rooms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateHotelRoomDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomsApi - functional programming interface
 * @export
 */
export const RoomsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new room
         * @param {CreateHotelRoomDto} createHotelRoomDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerCreate(createHotelRoomDto: CreateHotelRoomDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HotelRoom>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerCreate(createHotelRoomDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all soft-deleted rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerFindDeleted(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HotelRoom>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerFindDeleted(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomControllerFindDeleted']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all rooms with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterHotelRoomDto
         * @param {string} [sort] JSON string of SortHotelRoomDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HotelRoomPaginationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerFindMany(page, pageSize, filters, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary ADMIN - STAFF Get all rooms by branch ID
         * @param {string} branchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerFindManyByBranchId(branchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HotelRoom>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerFindManyByBranchId(branchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomControllerFindManyByBranchId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a room by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HotelRoom>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary ADMIN - Delete rooms permanently
         * @param {ImmediateDeleteRoomsDto} immediateDeleteRoomsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerPermanentDelete(immediateDeleteRoomsDto: ImmediateDeleteRoomsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerPermanentDelete(immediateDeleteRoomsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomControllerPermanentDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a room
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Restore a soft-deleted room
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerRestore(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HotelRoom>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerRestore(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomControllerRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a room
         * @param {string} id 
         * @param {UpdateHotelRoomDto} updateHotelRoomDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerUpdate(id: string, updateHotelRoomDto: UpdateHotelRoomDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HotelRoom>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerUpdate(id, updateHotelRoomDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomsApi.roomControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoomsApi - factory interface
 * @export
 */
export const RoomsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new room
         * @param {CreateHotelRoomDto} createHotelRoomDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerCreate(createHotelRoomDto: CreateHotelRoomDto, options?: RawAxiosRequestConfig): AxiosPromise<HotelRoom> {
            return localVarFp.roomControllerCreate(createHotelRoomDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all soft-deleted rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerFindDeleted(options?: RawAxiosRequestConfig): AxiosPromise<Array<HotelRoom>> {
            return localVarFp.roomControllerFindDeleted(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all rooms with pagination and filters
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterHotelRoomDto
         * @param {string} [sort] JSON string of SortHotelRoomDto[]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<HotelRoomPaginationResultDto> {
            return localVarFp.roomControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ADMIN - STAFF Get all rooms by branch ID
         * @param {string} branchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerFindManyByBranchId(branchId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<HotelRoom>> {
            return localVarFp.roomControllerFindManyByBranchId(branchId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a room by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<HotelRoom> {
            return localVarFp.roomControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ADMIN - Delete rooms permanently
         * @param {ImmediateDeleteRoomsDto} immediateDeleteRoomsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerPermanentDelete(immediateDeleteRoomsDto: ImmediateDeleteRoomsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomControllerPermanentDelete(immediateDeleteRoomsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a room
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.roomControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a soft-deleted room
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerRestore(id: string, options?: RawAxiosRequestConfig): AxiosPromise<HotelRoom> {
            return localVarFp.roomControllerRestore(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a room
         * @param {string} id 
         * @param {UpdateHotelRoomDto} updateHotelRoomDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerUpdate(id: string, updateHotelRoomDto: UpdateHotelRoomDto, options?: RawAxiosRequestConfig): AxiosPromise<HotelRoom> {
            return localVarFp.roomControllerUpdate(id, updateHotelRoomDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomsApi - object-oriented interface
 * @export
 * @class RoomsApi
 * @extends {BaseAPI}
 */
export class RoomsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new room
     * @param {CreateHotelRoomDto} createHotelRoomDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomControllerCreate(createHotelRoomDto: CreateHotelRoomDto, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomControllerCreate(createHotelRoomDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all soft-deleted rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomControllerFindDeleted(options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomControllerFindDeleted(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all rooms with pagination and filters
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [filters] JSON string of FilterHotelRoomDto
     * @param {string} [sort] JSON string of SortHotelRoomDto[]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomControllerFindMany(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomControllerFindMany(page, pageSize, filters, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ADMIN - STAFF Get all rooms by branch ID
     * @param {string} branchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomControllerFindManyByBranchId(branchId: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomControllerFindManyByBranchId(branchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a room by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ADMIN - Delete rooms permanently
     * @param {ImmediateDeleteRoomsDto} immediateDeleteRoomsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomControllerPermanentDelete(immediateDeleteRoomsDto: ImmediateDeleteRoomsDto, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomControllerPermanentDelete(immediateDeleteRoomsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a room
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a soft-deleted room
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomControllerRestore(id: string, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomControllerRestore(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a room
     * @param {string} id 
     * @param {UpdateHotelRoomDto} updateHotelRoomDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public roomControllerUpdate(id: string, updateHotelRoomDto: UpdateHotelRoomDto, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).roomControllerUpdate(id, updateHotelRoomDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get detailed user information (Admin only)
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerAdminGetUserDetail: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersControllerAdminGetUserDetail', 'id', id)
            const localVarPath = `/api/users/admin/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user information (Admin only)
         * @param {string} id 
         * @param {AdminUpdateUserDto} adminUpdateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerAdminUpdateUser: async (id: string, adminUpdateUserDto: AdminUpdateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersControllerAdminUpdateUser', 'id', id)
            // verify required parameter 'adminUpdateUserDto' is not null or undefined
            assertParamExists('usersControllerAdminUpdateUser', 'adminUpdateUserDto', adminUpdateUserDto)
            const localVarPath = `/api/users/admin/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUpdateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Block or unblock a user
         * @param {string} id 
         * @param {BlockOrUnblockUserDto} blockOrUnblockUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerBlockUser: async (id: string, blockOrUnblockUserDto: BlockOrUnblockUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersControllerBlockUser', 'id', id)
            // verify required parameter 'blockOrUnblockUserDto' is not null or undefined
            assertParamExists('usersControllerBlockUser', 'blockOrUnblockUserDto', blockOrUnblockUserDto)
            const localVarPath = `/api/users/block-action/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blockOrUnblockUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft delete a user (Admin only)
         * @param {string} id 
         * @param {DeleteUserDto} deleteUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerDeleteUser: async (id: string, deleteUserDto: DeleteUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersControllerDeleteUser', 'id', id)
            // verify required parameter 'deleteUserDto' is not null or undefined
            assertParamExists('usersControllerDeleteUser', 'deleteUserDto', deleteUserDto)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterUserDto
         * @param {string} [sort] JSON string of SortUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetUsers: async (page?: number, pageSize?: number, filters?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a deleted user (Admin only)
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerRestoreUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersControllerRestoreUser', 'id', id)
            const localVarPath = `/api/users/{id}/restore`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get detailed user information (Admin only)
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerAdminGetUserDetail(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerAdminGetUserDetail(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerAdminGetUserDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user information (Admin only)
         * @param {string} id 
         * @param {AdminUpdateUserDto} adminUpdateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerAdminUpdateUser(id: string, adminUpdateUserDto: AdminUpdateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerAdminUpdateUser(id, adminUpdateUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerAdminUpdateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Block or unblock a user
         * @param {string} id 
         * @param {BlockOrUnblockUserDto} blockOrUnblockUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerBlockUser(id: string, blockOrUnblockUserDto: BlockOrUnblockUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerBlockUser(id, blockOrUnblockUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerBlockUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Soft delete a user (Admin only)
         * @param {string} id 
         * @param {DeleteUserDto} deleteUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerDeleteUser(id: string, deleteUserDto: DeleteUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerDeleteUser(id, deleteUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerDeleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterUserDto
         * @param {string} [sort] JSON string of SortUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetUsers(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersPaginationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetUsers(page, pageSize, filters, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Restore a deleted user (Admin only)
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerRestoreUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerRestoreUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerRestoreUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get detailed user information (Admin only)
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerAdminGetUserDetail(id: string, options?: RawAxiosRequestConfig): AxiosPromise<UserDetail> {
            return localVarFp.usersControllerAdminGetUserDetail(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user information (Admin only)
         * @param {string} id 
         * @param {AdminUpdateUserDto} adminUpdateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerAdminUpdateUser(id: string, adminUpdateUserDto: AdminUpdateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<UserDetail> {
            return localVarFp.usersControllerAdminUpdateUser(id, adminUpdateUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Block or unblock a user
         * @param {string} id 
         * @param {BlockOrUnblockUserDto} blockOrUnblockUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerBlockUser(id: string, blockOrUnblockUserDto: BlockOrUnblockUserDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersControllerBlockUser(id, blockOrUnblockUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft delete a user (Admin only)
         * @param {string} id 
         * @param {DeleteUserDto} deleteUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerDeleteUser(id: string, deleteUserDto: DeleteUserDto, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersControllerDeleteUser(id, deleteUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [filters] JSON string of FilterUserDto
         * @param {string} [sort] JSON string of SortUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetUsers(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<UsersPaginationResultDto> {
            return localVarFp.usersControllerGetUsers(page, pageSize, filters, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a deleted user (Admin only)
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerRestoreUser(id: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersControllerRestoreUser(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Get detailed user information (Admin only)
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerAdminGetUserDetail(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerAdminGetUserDetail(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user information (Admin only)
     * @param {string} id 
     * @param {AdminUpdateUserDto} adminUpdateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerAdminUpdateUser(id: string, adminUpdateUserDto: AdminUpdateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerAdminUpdateUser(id, adminUpdateUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Block or unblock a user
     * @param {string} id 
     * @param {BlockOrUnblockUserDto} blockOrUnblockUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerBlockUser(id: string, blockOrUnblockUserDto: BlockOrUnblockUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerBlockUser(id, blockOrUnblockUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft delete a user (Admin only)
     * @param {string} id 
     * @param {DeleteUserDto} deleteUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerDeleteUser(id: string, deleteUserDto: DeleteUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerDeleteUser(id, deleteUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [filters] JSON string of FilterUserDto
     * @param {string} [sort] JSON string of SortUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetUsers(page?: number, pageSize?: number, filters?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetUsers(page, pageSize, filters, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a deleted user (Admin only)
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerRestoreUser(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerRestoreUser(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VerificationApi - axios parameter creator
 * @export
 */
export const VerificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Verify a code
         * @param {VerifyCodeDto} verifyCodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verificationControllerVerifyCode: async (verifyCodeDto: VerifyCodeDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyCodeDto' is not null or undefined
            assertParamExists('verificationControllerVerifyCode', 'verifyCodeDto', verifyCodeDto)
            const localVarPath = `/api/verification/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyCodeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify an email OTP
         * @param {VerifyEmailOTP} verifyEmailOTP 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verificationControllerVerifyEmailOTP: async (verifyEmailOTP: VerifyEmailOTP, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyEmailOTP' is not null or undefined
            assertParamExists('verificationControllerVerifyEmailOTP', 'verifyEmailOTP', verifyEmailOTP)
            const localVarPath = `/api/verification/verify-email-otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyEmailOTP, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VerificationApi - functional programming interface
 * @export
 */
export const VerificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VerificationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Verify a code
         * @param {VerifyCodeDto} verifyCodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verificationControllerVerifyCode(verifyCodeDto: VerifyCodeDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyCodeResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verificationControllerVerifyCode(verifyCodeDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VerificationApi.verificationControllerVerifyCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify an email OTP
         * @param {VerifyEmailOTP} verifyEmailOTP 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verificationControllerVerifyEmailOTP(verifyEmailOTP: VerifyEmailOTP, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyCodeResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verificationControllerVerifyEmailOTP(verifyEmailOTP, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VerificationApi.verificationControllerVerifyEmailOTP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VerificationApi - factory interface
 * @export
 */
export const VerificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VerificationApiFp(configuration)
    return {
        /**
         * 
         * @summary Verify a code
         * @param {VerifyCodeDto} verifyCodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verificationControllerVerifyCode(verifyCodeDto: VerifyCodeDto, options?: RawAxiosRequestConfig): AxiosPromise<VerifyCodeResponseDto> {
            return localVarFp.verificationControllerVerifyCode(verifyCodeDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify an email OTP
         * @param {VerifyEmailOTP} verifyEmailOTP 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verificationControllerVerifyEmailOTP(verifyEmailOTP: VerifyEmailOTP, options?: RawAxiosRequestConfig): AxiosPromise<VerifyCodeResponseDto> {
            return localVarFp.verificationControllerVerifyEmailOTP(verifyEmailOTP, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VerificationApi - object-oriented interface
 * @export
 * @class VerificationApi
 * @extends {BaseAPI}
 */
export class VerificationApi extends BaseAPI {
    /**
     * 
     * @summary Verify a code
     * @param {VerifyCodeDto} verifyCodeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public verificationControllerVerifyCode(verifyCodeDto: VerifyCodeDto, options?: RawAxiosRequestConfig) {
        return VerificationApiFp(this.configuration).verificationControllerVerifyCode(verifyCodeDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify an email OTP
     * @param {VerifyEmailOTP} verifyEmailOTP 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public verificationControllerVerifyEmailOTP(verifyEmailOTP: VerifyEmailOTP, options?: RawAxiosRequestConfig) {
        return VerificationApiFp(this.configuration).verificationControllerVerifyEmailOTP(verifyEmailOTP, options).then((request) => request(this.axios, this.basePath));
    }
}



